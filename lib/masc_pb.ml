(********************************************************)
(*           AUTOGENERATED FILE - DO NOT EDIT!          *)
(********************************************************)
(* Generated by: ocaml-protoc-plugin                    *)
(* https://github.com/andersfugmann/ocaml-protoc-plugin *)
(********************************************************)
(*
  Source: proto/masc.proto
  Syntax: proto3
  Parameters:
    debug=false
    annot=''
    opens=[]
    int64_as_int=true
    int32_as_int=true
    fixed_as_int=false
    singleton_record=false
    prefix_output_with_package=false
*)
[@@@ocaml.alert "-protobuf"] (* Disable deprecation warnings for protobuf*)
(**/**)
module Runtime' = Ocaml_protoc_plugin [@@warning "-33"]
module Imported'modules = struct
end
(**/**)
module rec Masc : sig
  module rec V1 : sig

    (**
{%html:
<p>===== Core Types =====</p>
%}
    *)
    module rec Empty : sig
      type t = unit
      val make: unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and Agent : sig
      type t = {
        name:string;
        status:string;
        (**
{%html:
<p>&quot;active&quot;, &quot;idle&quot;, &quot;zombie&quot;</p>
%}
        *)

        capabilities:string list;
        last_heartbeat:string;
        joined_at:string;
      }
      val make: ?name:string -> ?status:string -> ?capabilities:string list -> ?last_heartbeat:string -> ?joined_at:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?name:string -> ?status:string -> ?capabilities:string list -> ?last_heartbeat:string -> ?joined_at:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and Task : sig
      type t = {
        id:string;
        title:string;
        description:string;
        status:string;
        (**
{%html:
<p>&quot;pending&quot;, &quot;claimed&quot;, &quot;in_progress&quot;, &quot;done&quot;, &quot;cancelled&quot;</p>
%}
        *)

        assigned_to:string;
        priority:int;
        created_at:string;
        updated_at:string;
      }
      val make: ?id:string -> ?title:string -> ?description:string -> ?status:string -> ?assigned_to:string -> ?priority:int -> ?created_at:string -> ?updated_at:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?id:string -> ?title:string -> ?description:string -> ?status:string -> ?assigned_to:string -> ?priority:int -> ?created_at:string -> ?updated_at:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and Message : sig
      type t = {
        id:string;
        from:string;
        content:string;
        timestamp:string;
        seq:int;
      }
      val make: ?id:string -> ?from:string -> ?content:string -> ?timestamp:string -> ?seq:int -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?id:string -> ?from:string -> ?content:string -> ?timestamp:string -> ?seq:int -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and Vote : sig
      type t = {
        id:string;
        topic:string;
        proposer:string;
        options:string list;
        votes:(string * string) list;
        required_votes:int;
        status:string;
        (**
{%html:
<p>&quot;active&quot;, &quot;resolved&quot;</p>
%}
        *)

        result:string;
      }
      val make: ?id:string -> ?topic:string -> ?proposer:string -> ?options:string list -> ?votes:(string * string) list -> ?required_votes:int -> ?status:string -> ?result:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?id:string -> ?topic:string -> ?proposer:string -> ?options:string list -> ?votes:(string * string) list -> ?required_votes:int -> ?status:string -> ?result:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and PlanningContext : sig
      type t = {
        task_id:string;
        task_plan:string;
        notes:string list;
        deliverable:string;
        created_at:string;
        updated_at:string;
      }
      val make: ?task_id:string -> ?task_plan:string -> ?notes:string list -> ?deliverable:string -> ?created_at:string -> ?updated_at:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?task_id:string -> ?task_plan:string -> ?notes:string list -> ?deliverable:string -> ?created_at:string -> ?updated_at:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end


    (**
{%html:
<p>Status</p>
<p>===== Request/Response Messages =====</p>
%}
    *)
    and StatusRequest : sig
      type t = unit
      val make: unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and StatusResponse : sig
      type t = {
        agents:Agent.t list;
        tasks:Task.t list;
        message_count:int;
        room_path:string;
        project_name:string;
      }
      val make: ?agents:Agent.t list -> ?tasks:Task.t list -> ?message_count:int -> ?room_path:string -> ?project_name:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?agents:Agent.t list -> ?tasks:Task.t list -> ?message_count:int -> ?room_path:string -> ?project_name:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end


    (**
{%html:
<p>Agent Operations</p>
%}
    *)
    and JoinRequest : sig
      type t = {
        agent_name:string;
        capabilities:string list;
      }
      val make: ?agent_name:string -> ?capabilities:string list -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?agent_name:string -> ?capabilities:string list -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and JoinResponse : sig
      type t = {
        success:bool;
        message:string;
      }
      val make: ?success:bool -> ?message:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?success:bool -> ?message:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and LeaveRequest : sig
      type t = (string)
      val make: ?agent_name:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?agent_name:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and LeaveResponse : sig
      type t = {
        success:bool;
        message:string;
      }
      val make: ?success:bool -> ?message:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?success:bool -> ?message:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end


    (**
{%html:
<p>Task Operations</p>
%}
    *)
    and AddTaskRequest : sig
      type t = {
        title:string;
        description:string;
        priority:int;
      }
      val make: ?title:string -> ?description:string -> ?priority:int -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?title:string -> ?description:string -> ?priority:int -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and AddTaskResponse : sig
      type t = {
        success:bool;
        task_id:string;
        message:string;
      }
      val make: ?success:bool -> ?task_id:string -> ?message:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?success:bool -> ?task_id:string -> ?message:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and ClaimTaskRequest : sig
      type t = {
        agent_name:string;
        task_id:string;
      }
      val make: ?agent_name:string -> ?task_id:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?agent_name:string -> ?task_id:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and ClaimTaskResponse : sig
      type t = {
        success:bool;
        message:string;
      }
      val make: ?success:bool -> ?message:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?success:bool -> ?message:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and DoneTaskRequest : sig
      type t = {
        agent_name:string;
        task_id:string;
        notes:string;
      }
      val make: ?agent_name:string -> ?task_id:string -> ?notes:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?agent_name:string -> ?task_id:string -> ?notes:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and DoneTaskResponse : sig
      type t = {
        success:bool;
        message:string;
      }
      val make: ?success:bool -> ?message:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?success:bool -> ?message:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and CancelTaskRequest : sig
      type t = {
        agent_name:string;
        task_id:string;
        reason:string;
      }
      val make: ?agent_name:string -> ?task_id:string -> ?reason:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?agent_name:string -> ?task_id:string -> ?reason:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and CancelTaskResponse : sig
      type t = {
        success:bool;
        message:string;
      }
      val make: ?success:bool -> ?message:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?success:bool -> ?message:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end


    (**
{%html:
<p>Messaging</p>
%}
    *)
    and BroadcastRequest : sig
      type t = {
        agent_name:string;
        message:string;
      }
      val make: ?agent_name:string -> ?message:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?agent_name:string -> ?message:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and BroadcastResponse : sig
      type t = {
        success:bool;
        seq:int;
      }
      val make: ?success:bool -> ?seq:int -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?success:bool -> ?seq:int -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and GetMessagesRequest : sig
      type t = {
        since_seq:int;
        limit:int;
      }
      val make: ?since_seq:int -> ?limit:int -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?since_seq:int -> ?limit:int -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and GetMessagesResponse : sig
      type t = (Message.t list)
      val make: ?messages:Message.t list -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?messages:Message.t list -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end


    (**
{%html:
<p>Voting</p>
%}
    *)
    and CreateVoteRequest : sig
      type t = {
        proposer:string;
        topic:string;
        options:string list;
        required_votes:int;
      }
      val make: ?proposer:string -> ?topic:string -> ?options:string list -> ?required_votes:int -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?proposer:string -> ?topic:string -> ?options:string list -> ?required_votes:int -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and CreateVoteResponse : sig
      type t = {
        success:bool;
        vote_id:string;
      }
      val make: ?success:bool -> ?vote_id:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?success:bool -> ?vote_id:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and CastVoteRequest : sig
      type t = {
        agent_name:string;
        vote_id:string;
        choice:string;
      }
      val make: ?agent_name:string -> ?vote_id:string -> ?choice:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?agent_name:string -> ?vote_id:string -> ?choice:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and CastVoteResponse : sig
      type t = {
        success:bool;
        message:string;
        status:string;
        result:string;
      }
      val make: ?success:bool -> ?message:string -> ?status:string -> ?result:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?success:bool -> ?message:string -> ?status:string -> ?result:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end


    (**
{%html:
<p>Planning</p>
%}
    *)
    and InitPlanRequest : sig
      type t = (string)
      val make: ?task_id:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?task_id:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and InitPlanResponse : sig
      type t = {
        success:bool;
        context:PlanningContext.t option;
      }
      val make: ?success:bool -> ?context:PlanningContext.t -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?success:bool -> ?context:PlanningContext.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and UpdatePlanRequest : sig
      type t = {
        task_id:string;
        content:string;
      }
      val make: ?task_id:string -> ?content:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?task_id:string -> ?content:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and UpdatePlanResponse : sig
      type t = {
        success:bool;
        context:PlanningContext.t option;
      }
      val make: ?success:bool -> ?context:PlanningContext.t -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?success:bool -> ?context:PlanningContext.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and AddNoteRequest : sig
      type t = {
        task_id:string;
        note:string;
      }
      val make: ?task_id:string -> ?note:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?task_id:string -> ?note:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and AddNoteResponse : sig
      type t = {
        success:bool;
        context:PlanningContext.t option;
      }
      val make: ?success:bool -> ?context:PlanningContext.t -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?success:bool -> ?context:PlanningContext.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and GetPlanRequest : sig
      type t = (string)
      val make: ?task_id:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?task_id:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and GetPlanResponse : sig
      type t = {
        success:bool;
        context:PlanningContext.t option;
        markdown:string;
        (**
{%html:
<p>Formatted for LLM consumption</p>
%}
        *)

      }
      val make: ?success:bool -> ?context:PlanningContext.t -> ?markdown:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?success:bool -> ?context:PlanningContext.t -> ?markdown:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end


    (**
{%html:
<p>Streaming</p>
%}
    *)
    and StreamMessagesRequest : sig
      type t = {
        agent_name:string;
        since_seq:int;
      }
      val make: ?agent_name:string -> ?since_seq:int -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?agent_name:string -> ?since_seq:int -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    module MASCService : sig
      module GetStatus : sig
        include Runtime'.Service.Rpc with type Request.t = StatusRequest.t and type Response.t = StatusResponse.t
        module Request : Runtime'.Spec.Message with type t = StatusRequest.t and type make_t = StatusRequest.make_t
        (** Module alias for the request message for this method call *)

        module Response : Runtime'.Spec.Message with type t = StatusResponse.t and type make_t = StatusResponse.make_t
        (** Module alias for the response message for this method call *)

      end

      val getStatus : (module Runtime'.Spec.Message with type t = StatusRequest.t) * (module Runtime'.Spec.Message with type t = StatusResponse.t)
      module Join : sig
        include Runtime'.Service.Rpc with type Request.t = JoinRequest.t and type Response.t = JoinResponse.t
        module Request : Runtime'.Spec.Message with type t = JoinRequest.t and type make_t = JoinRequest.make_t
        (** Module alias for the request message for this method call *)

        module Response : Runtime'.Spec.Message with type t = JoinResponse.t and type make_t = JoinResponse.make_t
        (** Module alias for the response message for this method call *)

      end

      val join : (module Runtime'.Spec.Message with type t = JoinRequest.t) * (module Runtime'.Spec.Message with type t = JoinResponse.t)
      module Leave : sig
        include Runtime'.Service.Rpc with type Request.t = LeaveRequest.t and type Response.t = LeaveResponse.t
        module Request : Runtime'.Spec.Message with type t = LeaveRequest.t and type make_t = LeaveRequest.make_t
        (** Module alias for the request message for this method call *)

        module Response : Runtime'.Spec.Message with type t = LeaveResponse.t and type make_t = LeaveResponse.make_t
        (** Module alias for the response message for this method call *)

      end

      val leave : (module Runtime'.Spec.Message with type t = LeaveRequest.t) * (module Runtime'.Spec.Message with type t = LeaveResponse.t)
      module AddTask : sig
        include Runtime'.Service.Rpc with type Request.t = AddTaskRequest.t and type Response.t = AddTaskResponse.t
        module Request : Runtime'.Spec.Message with type t = AddTaskRequest.t and type make_t = AddTaskRequest.make_t
        (** Module alias for the request message for this method call *)

        module Response : Runtime'.Spec.Message with type t = AddTaskResponse.t and type make_t = AddTaskResponse.make_t
        (** Module alias for the response message for this method call *)

      end

      val addTask : (module Runtime'.Spec.Message with type t = AddTaskRequest.t) * (module Runtime'.Spec.Message with type t = AddTaskResponse.t)
      module ClaimTask : sig
        include Runtime'.Service.Rpc with type Request.t = ClaimTaskRequest.t and type Response.t = ClaimTaskResponse.t
        module Request : Runtime'.Spec.Message with type t = ClaimTaskRequest.t and type make_t = ClaimTaskRequest.make_t
        (** Module alias for the request message for this method call *)

        module Response : Runtime'.Spec.Message with type t = ClaimTaskResponse.t and type make_t = ClaimTaskResponse.make_t
        (** Module alias for the response message for this method call *)

      end

      val claimTask : (module Runtime'.Spec.Message with type t = ClaimTaskRequest.t) * (module Runtime'.Spec.Message with type t = ClaimTaskResponse.t)
      module DoneTask : sig
        include Runtime'.Service.Rpc with type Request.t = DoneTaskRequest.t and type Response.t = DoneTaskResponse.t
        module Request : Runtime'.Spec.Message with type t = DoneTaskRequest.t and type make_t = DoneTaskRequest.make_t
        (** Module alias for the request message for this method call *)

        module Response : Runtime'.Spec.Message with type t = DoneTaskResponse.t and type make_t = DoneTaskResponse.make_t
        (** Module alias for the response message for this method call *)

      end

      val doneTask : (module Runtime'.Spec.Message with type t = DoneTaskRequest.t) * (module Runtime'.Spec.Message with type t = DoneTaskResponse.t)
      module CancelTask : sig
        include Runtime'.Service.Rpc with type Request.t = CancelTaskRequest.t and type Response.t = CancelTaskResponse.t
        module Request : Runtime'.Spec.Message with type t = CancelTaskRequest.t and type make_t = CancelTaskRequest.make_t
        (** Module alias for the request message for this method call *)

        module Response : Runtime'.Spec.Message with type t = CancelTaskResponse.t and type make_t = CancelTaskResponse.make_t
        (** Module alias for the response message for this method call *)

      end

      val cancelTask : (module Runtime'.Spec.Message with type t = CancelTaskRequest.t) * (module Runtime'.Spec.Message with type t = CancelTaskResponse.t)
      module Broadcast : sig
        include Runtime'.Service.Rpc with type Request.t = BroadcastRequest.t and type Response.t = BroadcastResponse.t
        module Request : Runtime'.Spec.Message with type t = BroadcastRequest.t and type make_t = BroadcastRequest.make_t
        (** Module alias for the request message for this method call *)

        module Response : Runtime'.Spec.Message with type t = BroadcastResponse.t and type make_t = BroadcastResponse.make_t
        (** Module alias for the response message for this method call *)

      end

      val broadcast : (module Runtime'.Spec.Message with type t = BroadcastRequest.t) * (module Runtime'.Spec.Message with type t = BroadcastResponse.t)
      module GetMessages : sig
        include Runtime'.Service.Rpc with type Request.t = GetMessagesRequest.t and type Response.t = GetMessagesResponse.t
        module Request : Runtime'.Spec.Message with type t = GetMessagesRequest.t and type make_t = GetMessagesRequest.make_t
        (** Module alias for the request message for this method call *)

        module Response : Runtime'.Spec.Message with type t = GetMessagesResponse.t and type make_t = GetMessagesResponse.make_t
        (** Module alias for the response message for this method call *)

      end

      val getMessages : (module Runtime'.Spec.Message with type t = GetMessagesRequest.t) * (module Runtime'.Spec.Message with type t = GetMessagesResponse.t)
      module StreamMessages : sig
        include Runtime'.Service.Rpc with type Request.t = StreamMessagesRequest.t and type Response.t = Message.t
        module Request : Runtime'.Spec.Message with type t = StreamMessagesRequest.t and type make_t = StreamMessagesRequest.make_t
        (** Module alias for the request message for this method call *)

        module Response : Runtime'.Spec.Message with type t = Message.t and type make_t = Message.make_t
        (** Module alias for the response message for this method call *)

      end

      val streamMessages : (module Runtime'.Spec.Message with type t = StreamMessagesRequest.t) * (module Runtime'.Spec.Message with type t = Message.t)
      module CreateVote : sig
        include Runtime'.Service.Rpc with type Request.t = CreateVoteRequest.t and type Response.t = CreateVoteResponse.t
        module Request : Runtime'.Spec.Message with type t = CreateVoteRequest.t and type make_t = CreateVoteRequest.make_t
        (** Module alias for the request message for this method call *)

        module Response : Runtime'.Spec.Message with type t = CreateVoteResponse.t and type make_t = CreateVoteResponse.make_t
        (** Module alias for the response message for this method call *)

      end

      val createVote : (module Runtime'.Spec.Message with type t = CreateVoteRequest.t) * (module Runtime'.Spec.Message with type t = CreateVoteResponse.t)
      module CastVote : sig
        include Runtime'.Service.Rpc with type Request.t = CastVoteRequest.t and type Response.t = CastVoteResponse.t
        module Request : Runtime'.Spec.Message with type t = CastVoteRequest.t and type make_t = CastVoteRequest.make_t
        (** Module alias for the request message for this method call *)

        module Response : Runtime'.Spec.Message with type t = CastVoteResponse.t and type make_t = CastVoteResponse.make_t
        (** Module alias for the response message for this method call *)

      end

      val castVote : (module Runtime'.Spec.Message with type t = CastVoteRequest.t) * (module Runtime'.Spec.Message with type t = CastVoteResponse.t)
      module InitPlan : sig
        include Runtime'.Service.Rpc with type Request.t = InitPlanRequest.t and type Response.t = InitPlanResponse.t
        module Request : Runtime'.Spec.Message with type t = InitPlanRequest.t and type make_t = InitPlanRequest.make_t
        (** Module alias for the request message for this method call *)

        module Response : Runtime'.Spec.Message with type t = InitPlanResponse.t and type make_t = InitPlanResponse.make_t
        (** Module alias for the response message for this method call *)

      end

      val initPlan : (module Runtime'.Spec.Message with type t = InitPlanRequest.t) * (module Runtime'.Spec.Message with type t = InitPlanResponse.t)
      module UpdatePlan : sig
        include Runtime'.Service.Rpc with type Request.t = UpdatePlanRequest.t and type Response.t = UpdatePlanResponse.t
        module Request : Runtime'.Spec.Message with type t = UpdatePlanRequest.t and type make_t = UpdatePlanRequest.make_t
        (** Module alias for the request message for this method call *)

        module Response : Runtime'.Spec.Message with type t = UpdatePlanResponse.t and type make_t = UpdatePlanResponse.make_t
        (** Module alias for the response message for this method call *)

      end

      val updatePlan : (module Runtime'.Spec.Message with type t = UpdatePlanRequest.t) * (module Runtime'.Spec.Message with type t = UpdatePlanResponse.t)
      module AddNote : sig
        include Runtime'.Service.Rpc with type Request.t = AddNoteRequest.t and type Response.t = AddNoteResponse.t
        module Request : Runtime'.Spec.Message with type t = AddNoteRequest.t and type make_t = AddNoteRequest.make_t
        (** Module alias for the request message for this method call *)

        module Response : Runtime'.Spec.Message with type t = AddNoteResponse.t and type make_t = AddNoteResponse.make_t
        (** Module alias for the response message for this method call *)

      end

      val addNote : (module Runtime'.Spec.Message with type t = AddNoteRequest.t) * (module Runtime'.Spec.Message with type t = AddNoteResponse.t)
      module GetPlan : sig
        include Runtime'.Service.Rpc with type Request.t = GetPlanRequest.t and type Response.t = GetPlanResponse.t
        module Request : Runtime'.Spec.Message with type t = GetPlanRequest.t and type make_t = GetPlanRequest.make_t
        (** Module alias for the request message for this method call *)

        module Response : Runtime'.Spec.Message with type t = GetPlanResponse.t and type make_t = GetPlanResponse.make_t
        (** Module alias for the response message for this method call *)

      end

      val getPlan : (module Runtime'.Spec.Message with type t = GetPlanRequest.t) * (module Runtime'.Spec.Message with type t = GetPlanResponse.t)
    end

  end
end = struct
  module rec V1 : sig

    (**
{%html:
<p>===== Core Types =====</p>
%}
    *)
    module rec Empty : sig
      type t = unit
      val make: unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and Agent : sig
      type t = {
        name:string;
        status:string;
        (**
{%html:
<p>&quot;active&quot;, &quot;idle&quot;, &quot;zombie&quot;</p>
%}
        *)

        capabilities:string list;
        last_heartbeat:string;
        joined_at:string;
      }
      val make: ?name:string -> ?status:string -> ?capabilities:string list -> ?last_heartbeat:string -> ?joined_at:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?name:string -> ?status:string -> ?capabilities:string list -> ?last_heartbeat:string -> ?joined_at:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and Task : sig
      type t = {
        id:string;
        title:string;
        description:string;
        status:string;
        (**
{%html:
<p>&quot;pending&quot;, &quot;claimed&quot;, &quot;in_progress&quot;, &quot;done&quot;, &quot;cancelled&quot;</p>
%}
        *)

        assigned_to:string;
        priority:int;
        created_at:string;
        updated_at:string;
      }
      val make: ?id:string -> ?title:string -> ?description:string -> ?status:string -> ?assigned_to:string -> ?priority:int -> ?created_at:string -> ?updated_at:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?id:string -> ?title:string -> ?description:string -> ?status:string -> ?assigned_to:string -> ?priority:int -> ?created_at:string -> ?updated_at:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and Message : sig
      type t = {
        id:string;
        from:string;
        content:string;
        timestamp:string;
        seq:int;
      }
      val make: ?id:string -> ?from:string -> ?content:string -> ?timestamp:string -> ?seq:int -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?id:string -> ?from:string -> ?content:string -> ?timestamp:string -> ?seq:int -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and Vote : sig
      type t = {
        id:string;
        topic:string;
        proposer:string;
        options:string list;
        votes:(string * string) list;
        required_votes:int;
        status:string;
        (**
{%html:
<p>&quot;active&quot;, &quot;resolved&quot;</p>
%}
        *)

        result:string;
      }
      val make: ?id:string -> ?topic:string -> ?proposer:string -> ?options:string list -> ?votes:(string * string) list -> ?required_votes:int -> ?status:string -> ?result:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?id:string -> ?topic:string -> ?proposer:string -> ?options:string list -> ?votes:(string * string) list -> ?required_votes:int -> ?status:string -> ?result:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and PlanningContext : sig
      type t = {
        task_id:string;
        task_plan:string;
        notes:string list;
        deliverable:string;
        created_at:string;
        updated_at:string;
      }
      val make: ?task_id:string -> ?task_plan:string -> ?notes:string list -> ?deliverable:string -> ?created_at:string -> ?updated_at:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?task_id:string -> ?task_plan:string -> ?notes:string list -> ?deliverable:string -> ?created_at:string -> ?updated_at:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end


    (**
{%html:
<p>Status</p>
<p>===== Request/Response Messages =====</p>
%}
    *)
    and StatusRequest : sig
      type t = unit
      val make: unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and StatusResponse : sig
      type t = {
        agents:Agent.t list;
        tasks:Task.t list;
        message_count:int;
        room_path:string;
        project_name:string;
      }
      val make: ?agents:Agent.t list -> ?tasks:Task.t list -> ?message_count:int -> ?room_path:string -> ?project_name:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?agents:Agent.t list -> ?tasks:Task.t list -> ?message_count:int -> ?room_path:string -> ?project_name:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end


    (**
{%html:
<p>Agent Operations</p>
%}
    *)
    and JoinRequest : sig
      type t = {
        agent_name:string;
        capabilities:string list;
      }
      val make: ?agent_name:string -> ?capabilities:string list -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?agent_name:string -> ?capabilities:string list -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and JoinResponse : sig
      type t = {
        success:bool;
        message:string;
      }
      val make: ?success:bool -> ?message:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?success:bool -> ?message:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and LeaveRequest : sig
      type t = (string)
      val make: ?agent_name:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?agent_name:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and LeaveResponse : sig
      type t = {
        success:bool;
        message:string;
      }
      val make: ?success:bool -> ?message:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?success:bool -> ?message:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end


    (**
{%html:
<p>Task Operations</p>
%}
    *)
    and AddTaskRequest : sig
      type t = {
        title:string;
        description:string;
        priority:int;
      }
      val make: ?title:string -> ?description:string -> ?priority:int -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?title:string -> ?description:string -> ?priority:int -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and AddTaskResponse : sig
      type t = {
        success:bool;
        task_id:string;
        message:string;
      }
      val make: ?success:bool -> ?task_id:string -> ?message:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?success:bool -> ?task_id:string -> ?message:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and ClaimTaskRequest : sig
      type t = {
        agent_name:string;
        task_id:string;
      }
      val make: ?agent_name:string -> ?task_id:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?agent_name:string -> ?task_id:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and ClaimTaskResponse : sig
      type t = {
        success:bool;
        message:string;
      }
      val make: ?success:bool -> ?message:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?success:bool -> ?message:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and DoneTaskRequest : sig
      type t = {
        agent_name:string;
        task_id:string;
        notes:string;
      }
      val make: ?agent_name:string -> ?task_id:string -> ?notes:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?agent_name:string -> ?task_id:string -> ?notes:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and DoneTaskResponse : sig
      type t = {
        success:bool;
        message:string;
      }
      val make: ?success:bool -> ?message:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?success:bool -> ?message:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and CancelTaskRequest : sig
      type t = {
        agent_name:string;
        task_id:string;
        reason:string;
      }
      val make: ?agent_name:string -> ?task_id:string -> ?reason:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?agent_name:string -> ?task_id:string -> ?reason:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and CancelTaskResponse : sig
      type t = {
        success:bool;
        message:string;
      }
      val make: ?success:bool -> ?message:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?success:bool -> ?message:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end


    (**
{%html:
<p>Messaging</p>
%}
    *)
    and BroadcastRequest : sig
      type t = {
        agent_name:string;
        message:string;
      }
      val make: ?agent_name:string -> ?message:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?agent_name:string -> ?message:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and BroadcastResponse : sig
      type t = {
        success:bool;
        seq:int;
      }
      val make: ?success:bool -> ?seq:int -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?success:bool -> ?seq:int -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and GetMessagesRequest : sig
      type t = {
        since_seq:int;
        limit:int;
      }
      val make: ?since_seq:int -> ?limit:int -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?since_seq:int -> ?limit:int -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and GetMessagesResponse : sig
      type t = (Message.t list)
      val make: ?messages:Message.t list -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?messages:Message.t list -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end


    (**
{%html:
<p>Voting</p>
%}
    *)
    and CreateVoteRequest : sig
      type t = {
        proposer:string;
        topic:string;
        options:string list;
        required_votes:int;
      }
      val make: ?proposer:string -> ?topic:string -> ?options:string list -> ?required_votes:int -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?proposer:string -> ?topic:string -> ?options:string list -> ?required_votes:int -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and CreateVoteResponse : sig
      type t = {
        success:bool;
        vote_id:string;
      }
      val make: ?success:bool -> ?vote_id:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?success:bool -> ?vote_id:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and CastVoteRequest : sig
      type t = {
        agent_name:string;
        vote_id:string;
        choice:string;
      }
      val make: ?agent_name:string -> ?vote_id:string -> ?choice:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?agent_name:string -> ?vote_id:string -> ?choice:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and CastVoteResponse : sig
      type t = {
        success:bool;
        message:string;
        status:string;
        result:string;
      }
      val make: ?success:bool -> ?message:string -> ?status:string -> ?result:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?success:bool -> ?message:string -> ?status:string -> ?result:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end


    (**
{%html:
<p>Planning</p>
%}
    *)
    and InitPlanRequest : sig
      type t = (string)
      val make: ?task_id:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?task_id:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and InitPlanResponse : sig
      type t = {
        success:bool;
        context:PlanningContext.t option;
      }
      val make: ?success:bool -> ?context:PlanningContext.t -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?success:bool -> ?context:PlanningContext.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and UpdatePlanRequest : sig
      type t = {
        task_id:string;
        content:string;
      }
      val make: ?task_id:string -> ?content:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?task_id:string -> ?content:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and UpdatePlanResponse : sig
      type t = {
        success:bool;
        context:PlanningContext.t option;
      }
      val make: ?success:bool -> ?context:PlanningContext.t -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?success:bool -> ?context:PlanningContext.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and AddNoteRequest : sig
      type t = {
        task_id:string;
        note:string;
      }
      val make: ?task_id:string -> ?note:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?task_id:string -> ?note:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and AddNoteResponse : sig
      type t = {
        success:bool;
        context:PlanningContext.t option;
      }
      val make: ?success:bool -> ?context:PlanningContext.t -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?success:bool -> ?context:PlanningContext.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and GetPlanRequest : sig
      type t = (string)
      val make: ?task_id:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?task_id:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    and GetPlanResponse : sig
      type t = {
        success:bool;
        context:PlanningContext.t option;
        markdown:string;
        (**
{%html:
<p>Formatted for LLM consumption</p>
%}
        *)

      }
      val make: ?success:bool -> ?context:PlanningContext.t -> ?markdown:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?success:bool -> ?context:PlanningContext.t -> ?markdown:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end


    (**
{%html:
<p>Streaming</p>
%}
    *)
    and StreamMessagesRequest : sig
      type t = {
        agent_name:string;
        since_seq:int;
      }
      val make: ?agent_name:string -> ?since_seq:int -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?agent_name:string -> ?since_seq:int -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end

    module MASCService : sig
      module GetStatus : sig
        include Runtime'.Service.Rpc with type Request.t = StatusRequest.t and type Response.t = StatusResponse.t
        module Request : Runtime'.Spec.Message with type t = StatusRequest.t and type make_t = StatusRequest.make_t
        (** Module alias for the request message for this method call *)

        module Response : Runtime'.Spec.Message with type t = StatusResponse.t and type make_t = StatusResponse.make_t
        (** Module alias for the response message for this method call *)

      end

      val getStatus : (module Runtime'.Spec.Message with type t = StatusRequest.t) * (module Runtime'.Spec.Message with type t = StatusResponse.t)
      module Join : sig
        include Runtime'.Service.Rpc with type Request.t = JoinRequest.t and type Response.t = JoinResponse.t
        module Request : Runtime'.Spec.Message with type t = JoinRequest.t and type make_t = JoinRequest.make_t
        (** Module alias for the request message for this method call *)

        module Response : Runtime'.Spec.Message with type t = JoinResponse.t and type make_t = JoinResponse.make_t
        (** Module alias for the response message for this method call *)

      end

      val join : (module Runtime'.Spec.Message with type t = JoinRequest.t) * (module Runtime'.Spec.Message with type t = JoinResponse.t)
      module Leave : sig
        include Runtime'.Service.Rpc with type Request.t = LeaveRequest.t and type Response.t = LeaveResponse.t
        module Request : Runtime'.Spec.Message with type t = LeaveRequest.t and type make_t = LeaveRequest.make_t
        (** Module alias for the request message for this method call *)

        module Response : Runtime'.Spec.Message with type t = LeaveResponse.t and type make_t = LeaveResponse.make_t
        (** Module alias for the response message for this method call *)

      end

      val leave : (module Runtime'.Spec.Message with type t = LeaveRequest.t) * (module Runtime'.Spec.Message with type t = LeaveResponse.t)
      module AddTask : sig
        include Runtime'.Service.Rpc with type Request.t = AddTaskRequest.t and type Response.t = AddTaskResponse.t
        module Request : Runtime'.Spec.Message with type t = AddTaskRequest.t and type make_t = AddTaskRequest.make_t
        (** Module alias for the request message for this method call *)

        module Response : Runtime'.Spec.Message with type t = AddTaskResponse.t and type make_t = AddTaskResponse.make_t
        (** Module alias for the response message for this method call *)

      end

      val addTask : (module Runtime'.Spec.Message with type t = AddTaskRequest.t) * (module Runtime'.Spec.Message with type t = AddTaskResponse.t)
      module ClaimTask : sig
        include Runtime'.Service.Rpc with type Request.t = ClaimTaskRequest.t and type Response.t = ClaimTaskResponse.t
        module Request : Runtime'.Spec.Message with type t = ClaimTaskRequest.t and type make_t = ClaimTaskRequest.make_t
        (** Module alias for the request message for this method call *)

        module Response : Runtime'.Spec.Message with type t = ClaimTaskResponse.t and type make_t = ClaimTaskResponse.make_t
        (** Module alias for the response message for this method call *)

      end

      val claimTask : (module Runtime'.Spec.Message with type t = ClaimTaskRequest.t) * (module Runtime'.Spec.Message with type t = ClaimTaskResponse.t)
      module DoneTask : sig
        include Runtime'.Service.Rpc with type Request.t = DoneTaskRequest.t and type Response.t = DoneTaskResponse.t
        module Request : Runtime'.Spec.Message with type t = DoneTaskRequest.t and type make_t = DoneTaskRequest.make_t
        (** Module alias for the request message for this method call *)

        module Response : Runtime'.Spec.Message with type t = DoneTaskResponse.t and type make_t = DoneTaskResponse.make_t
        (** Module alias for the response message for this method call *)

      end

      val doneTask : (module Runtime'.Spec.Message with type t = DoneTaskRequest.t) * (module Runtime'.Spec.Message with type t = DoneTaskResponse.t)
      module CancelTask : sig
        include Runtime'.Service.Rpc with type Request.t = CancelTaskRequest.t and type Response.t = CancelTaskResponse.t
        module Request : Runtime'.Spec.Message with type t = CancelTaskRequest.t and type make_t = CancelTaskRequest.make_t
        (** Module alias for the request message for this method call *)

        module Response : Runtime'.Spec.Message with type t = CancelTaskResponse.t and type make_t = CancelTaskResponse.make_t
        (** Module alias for the response message for this method call *)

      end

      val cancelTask : (module Runtime'.Spec.Message with type t = CancelTaskRequest.t) * (module Runtime'.Spec.Message with type t = CancelTaskResponse.t)
      module Broadcast : sig
        include Runtime'.Service.Rpc with type Request.t = BroadcastRequest.t and type Response.t = BroadcastResponse.t
        module Request : Runtime'.Spec.Message with type t = BroadcastRequest.t and type make_t = BroadcastRequest.make_t
        (** Module alias for the request message for this method call *)

        module Response : Runtime'.Spec.Message with type t = BroadcastResponse.t and type make_t = BroadcastResponse.make_t
        (** Module alias for the response message for this method call *)

      end

      val broadcast : (module Runtime'.Spec.Message with type t = BroadcastRequest.t) * (module Runtime'.Spec.Message with type t = BroadcastResponse.t)
      module GetMessages : sig
        include Runtime'.Service.Rpc with type Request.t = GetMessagesRequest.t and type Response.t = GetMessagesResponse.t
        module Request : Runtime'.Spec.Message with type t = GetMessagesRequest.t and type make_t = GetMessagesRequest.make_t
        (** Module alias for the request message for this method call *)

        module Response : Runtime'.Spec.Message with type t = GetMessagesResponse.t and type make_t = GetMessagesResponse.make_t
        (** Module alias for the response message for this method call *)

      end

      val getMessages : (module Runtime'.Spec.Message with type t = GetMessagesRequest.t) * (module Runtime'.Spec.Message with type t = GetMessagesResponse.t)
      module StreamMessages : sig
        include Runtime'.Service.Rpc with type Request.t = StreamMessagesRequest.t and type Response.t = Message.t
        module Request : Runtime'.Spec.Message with type t = StreamMessagesRequest.t and type make_t = StreamMessagesRequest.make_t
        (** Module alias for the request message for this method call *)

        module Response : Runtime'.Spec.Message with type t = Message.t and type make_t = Message.make_t
        (** Module alias for the response message for this method call *)

      end

      val streamMessages : (module Runtime'.Spec.Message with type t = StreamMessagesRequest.t) * (module Runtime'.Spec.Message with type t = Message.t)
      module CreateVote : sig
        include Runtime'.Service.Rpc with type Request.t = CreateVoteRequest.t and type Response.t = CreateVoteResponse.t
        module Request : Runtime'.Spec.Message with type t = CreateVoteRequest.t and type make_t = CreateVoteRequest.make_t
        (** Module alias for the request message for this method call *)

        module Response : Runtime'.Spec.Message with type t = CreateVoteResponse.t and type make_t = CreateVoteResponse.make_t
        (** Module alias for the response message for this method call *)

      end

      val createVote : (module Runtime'.Spec.Message with type t = CreateVoteRequest.t) * (module Runtime'.Spec.Message with type t = CreateVoteResponse.t)
      module CastVote : sig
        include Runtime'.Service.Rpc with type Request.t = CastVoteRequest.t and type Response.t = CastVoteResponse.t
        module Request : Runtime'.Spec.Message with type t = CastVoteRequest.t and type make_t = CastVoteRequest.make_t
        (** Module alias for the request message for this method call *)

        module Response : Runtime'.Spec.Message with type t = CastVoteResponse.t and type make_t = CastVoteResponse.make_t
        (** Module alias for the response message for this method call *)

      end

      val castVote : (module Runtime'.Spec.Message with type t = CastVoteRequest.t) * (module Runtime'.Spec.Message with type t = CastVoteResponse.t)
      module InitPlan : sig
        include Runtime'.Service.Rpc with type Request.t = InitPlanRequest.t and type Response.t = InitPlanResponse.t
        module Request : Runtime'.Spec.Message with type t = InitPlanRequest.t and type make_t = InitPlanRequest.make_t
        (** Module alias for the request message for this method call *)

        module Response : Runtime'.Spec.Message with type t = InitPlanResponse.t and type make_t = InitPlanResponse.make_t
        (** Module alias for the response message for this method call *)

      end

      val initPlan : (module Runtime'.Spec.Message with type t = InitPlanRequest.t) * (module Runtime'.Spec.Message with type t = InitPlanResponse.t)
      module UpdatePlan : sig
        include Runtime'.Service.Rpc with type Request.t = UpdatePlanRequest.t and type Response.t = UpdatePlanResponse.t
        module Request : Runtime'.Spec.Message with type t = UpdatePlanRequest.t and type make_t = UpdatePlanRequest.make_t
        (** Module alias for the request message for this method call *)

        module Response : Runtime'.Spec.Message with type t = UpdatePlanResponse.t and type make_t = UpdatePlanResponse.make_t
        (** Module alias for the response message for this method call *)

      end

      val updatePlan : (module Runtime'.Spec.Message with type t = UpdatePlanRequest.t) * (module Runtime'.Spec.Message with type t = UpdatePlanResponse.t)
      module AddNote : sig
        include Runtime'.Service.Rpc with type Request.t = AddNoteRequest.t and type Response.t = AddNoteResponse.t
        module Request : Runtime'.Spec.Message with type t = AddNoteRequest.t and type make_t = AddNoteRequest.make_t
        (** Module alias for the request message for this method call *)

        module Response : Runtime'.Spec.Message with type t = AddNoteResponse.t and type make_t = AddNoteResponse.make_t
        (** Module alias for the response message for this method call *)

      end

      val addNote : (module Runtime'.Spec.Message with type t = AddNoteRequest.t) * (module Runtime'.Spec.Message with type t = AddNoteResponse.t)
      module GetPlan : sig
        include Runtime'.Service.Rpc with type Request.t = GetPlanRequest.t and type Response.t = GetPlanResponse.t
        module Request : Runtime'.Spec.Message with type t = GetPlanRequest.t and type make_t = GetPlanRequest.make_t
        (** Module alias for the request message for this method call *)

        module Response : Runtime'.Spec.Message with type t = GetPlanResponse.t and type make_t = GetPlanResponse.make_t
        (** Module alias for the response message for this method call *)

      end

      val getPlan : (module Runtime'.Spec.Message with type t = GetPlanRequest.t) * (module Runtime'.Spec.Message with type t = GetPlanResponse.t)
    end

  end = struct
    module rec Empty : sig
      type t = unit
      val make: unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = Empty
      let name () = ".masc.v1.Empty"
      type t = unit
      type make_t = unit -> t
      let make () = ()
      let merge =

      fun () () -> ()
      let spec () = Runtime'.Spec.( nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer () -> serialize writer

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor  = () in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun () -> serialize
      let from_json_exn =
        let constructor  = () in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end

    and Agent : sig
      type t = {
        name:string;
        status:string;
        (**
{%html:
<p>&quot;active&quot;, &quot;idle&quot;, &quot;zombie&quot;</p>
%}
        *)

        capabilities:string list;
        last_heartbeat:string;
        joined_at:string;
      }
      val make: ?name:string -> ?status:string -> ?capabilities:string list -> ?last_heartbeat:string -> ?joined_at:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?name:string -> ?status:string -> ?capabilities:string list -> ?last_heartbeat:string -> ?joined_at:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = Agent
      let name () = ".masc.v1.Agent"
      type t = {
        name:string;
        status:string;
        capabilities:string list;
        last_heartbeat:string;
        joined_at:string;
      }
      type make_t = ?name:string -> ?status:string -> ?capabilities:string list -> ?last_heartbeat:string -> ?joined_at:string -> unit -> t
      let make ?(name = {||}) ?(status = {||}) ?(capabilities = []) ?(last_heartbeat = {||}) ?(joined_at = {||}) () = { name; status; capabilities; last_heartbeat; joined_at }
      let merge =
      let merge_name = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "name", "name"), string, ({||})) ) in
      let merge_status = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "status", "status"), string, ({||})) ) in
      let merge_capabilities = Runtime'.Merge.merge Runtime'.Spec.( repeated ((3, "capabilities", "capabilities"), string, not_packed) ) in
      let merge_last_heartbeat = Runtime'.Merge.merge Runtime'.Spec.( basic ((4, "last_heartbeat", "lastHeartbeat"), string, ({||})) ) in
      let merge_joined_at = Runtime'.Merge.merge Runtime'.Spec.( basic ((5, "joined_at", "joinedAt"), string, ({||})) ) in
      fun t1 t2 -> {
      	name = (merge_name t1.name t2.name);
      	status = (merge_status t1.status t2.status);
      	capabilities = (merge_capabilities t1.capabilities t2.capabilities);
      	last_heartbeat = (merge_last_heartbeat t1.last_heartbeat t2.last_heartbeat);
      	joined_at = (merge_joined_at t1.joined_at t2.joined_at);
       }
      let spec () = Runtime'.Spec.( basic ((1, "name", "name"), string, ({||})) ^:: basic ((2, "status", "status"), string, ({||})) ^:: repeated ((3, "capabilities", "capabilities"), string, not_packed) ^:: basic ((4, "last_heartbeat", "lastHeartbeat"), string, ({||})) ^:: basic ((5, "joined_at", "joinedAt"), string, ({||})) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer { name; status; capabilities; last_heartbeat; joined_at } -> serialize writer name status capabilities last_heartbeat joined_at

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor name status capabilities last_heartbeat joined_at = { name; status; capabilities; last_heartbeat; joined_at } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun { name; status; capabilities; last_heartbeat; joined_at } -> serialize name status capabilities last_heartbeat joined_at
      let from_json_exn =
        let constructor name status capabilities last_heartbeat joined_at = { name; status; capabilities; last_heartbeat; joined_at } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end

    and Task : sig
      type t = {
        id:string;
        title:string;
        description:string;
        status:string;
        (**
{%html:
<p>&quot;pending&quot;, &quot;claimed&quot;, &quot;in_progress&quot;, &quot;done&quot;, &quot;cancelled&quot;</p>
%}
        *)

        assigned_to:string;
        priority:int;
        created_at:string;
        updated_at:string;
      }
      val make: ?id:string -> ?title:string -> ?description:string -> ?status:string -> ?assigned_to:string -> ?priority:int -> ?created_at:string -> ?updated_at:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?id:string -> ?title:string -> ?description:string -> ?status:string -> ?assigned_to:string -> ?priority:int -> ?created_at:string -> ?updated_at:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = Task
      let name () = ".masc.v1.Task"
      type t = {
        id:string;
        title:string;
        description:string;
        status:string;
        assigned_to:string;
        priority:int;
        created_at:string;
        updated_at:string;
      }
      type make_t = ?id:string -> ?title:string -> ?description:string -> ?status:string -> ?assigned_to:string -> ?priority:int -> ?created_at:string -> ?updated_at:string -> unit -> t
      let make ?(id = {||}) ?(title = {||}) ?(description = {||}) ?(status = {||}) ?(assigned_to = {||}) ?(priority = 0) ?(created_at = {||}) ?(updated_at = {||}) () = { id; title; description; status; assigned_to; priority; created_at; updated_at }
      let merge =
      let merge_id = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "id", "id"), string, ({||})) ) in
      let merge_title = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "title", "title"), string, ({||})) ) in
      let merge_description = Runtime'.Merge.merge Runtime'.Spec.( basic ((3, "description", "description"), string, ({||})) ) in
      let merge_status = Runtime'.Merge.merge Runtime'.Spec.( basic ((4, "status", "status"), string, ({||})) ) in
      let merge_assigned_to = Runtime'.Merge.merge Runtime'.Spec.( basic ((5, "assigned_to", "assignedTo"), string, ({||})) ) in
      let merge_priority = Runtime'.Merge.merge Runtime'.Spec.( basic ((6, "priority", "priority"), int32_int, (0)) ) in
      let merge_created_at = Runtime'.Merge.merge Runtime'.Spec.( basic ((7, "created_at", "createdAt"), string, ({||})) ) in
      let merge_updated_at = Runtime'.Merge.merge Runtime'.Spec.( basic ((8, "updated_at", "updatedAt"), string, ({||})) ) in
      fun t1 t2 -> {
      	id = (merge_id t1.id t2.id);
      	title = (merge_title t1.title t2.title);
      	description = (merge_description t1.description t2.description);
      	status = (merge_status t1.status t2.status);
      	assigned_to = (merge_assigned_to t1.assigned_to t2.assigned_to);
      	priority = (merge_priority t1.priority t2.priority);
      	created_at = (merge_created_at t1.created_at t2.created_at);
      	updated_at = (merge_updated_at t1.updated_at t2.updated_at);
       }
      let spec () = Runtime'.Spec.( basic ((1, "id", "id"), string, ({||})) ^:: basic ((2, "title", "title"), string, ({||})) ^:: basic ((3, "description", "description"), string, ({||})) ^:: basic ((4, "status", "status"), string, ({||})) ^:: basic ((5, "assigned_to", "assignedTo"), string, ({||})) ^:: basic ((6, "priority", "priority"), int32_int, (0)) ^:: basic ((7, "created_at", "createdAt"), string, ({||})) ^:: basic ((8, "updated_at", "updatedAt"), string, ({||})) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer { id; title; description; status; assigned_to; priority; created_at; updated_at } -> serialize writer id title description status assigned_to priority created_at updated_at

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor id title description status assigned_to priority created_at updated_at = { id; title; description; status; assigned_to; priority; created_at; updated_at } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun { id; title; description; status; assigned_to; priority; created_at; updated_at } -> serialize id title description status assigned_to priority created_at updated_at
      let from_json_exn =
        let constructor id title description status assigned_to priority created_at updated_at = { id; title; description; status; assigned_to; priority; created_at; updated_at } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end

    and Message : sig
      type t = {
        id:string;
        from:string;
        content:string;
        timestamp:string;
        seq:int;
      }
      val make: ?id:string -> ?from:string -> ?content:string -> ?timestamp:string -> ?seq:int -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?id:string -> ?from:string -> ?content:string -> ?timestamp:string -> ?seq:int -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = Message
      let name () = ".masc.v1.Message"
      type t = {
        id:string;
        from:string;
        content:string;
        timestamp:string;
        seq:int;
      }
      type make_t = ?id:string -> ?from:string -> ?content:string -> ?timestamp:string -> ?seq:int -> unit -> t
      let make ?(id = {||}) ?(from = {||}) ?(content = {||}) ?(timestamp = {||}) ?(seq = 0) () = { id; from; content; timestamp; seq }
      let merge =
      let merge_id = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "id", "id"), string, ({||})) ) in
      let merge_from = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "from", "from"), string, ({||})) ) in
      let merge_content = Runtime'.Merge.merge Runtime'.Spec.( basic ((3, "content", "content"), string, ({||})) ) in
      let merge_timestamp = Runtime'.Merge.merge Runtime'.Spec.( basic ((4, "timestamp", "timestamp"), string, ({||})) ) in
      let merge_seq = Runtime'.Merge.merge Runtime'.Spec.( basic ((5, "seq", "seq"), int64_int, (0)) ) in
      fun t1 t2 -> {
      	id = (merge_id t1.id t2.id);
      	from = (merge_from t1.from t2.from);
      	content = (merge_content t1.content t2.content);
      	timestamp = (merge_timestamp t1.timestamp t2.timestamp);
      	seq = (merge_seq t1.seq t2.seq);
       }
      let spec () = Runtime'.Spec.( basic ((1, "id", "id"), string, ({||})) ^:: basic ((2, "from", "from"), string, ({||})) ^:: basic ((3, "content", "content"), string, ({||})) ^:: basic ((4, "timestamp", "timestamp"), string, ({||})) ^:: basic ((5, "seq", "seq"), int64_int, (0)) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer { id; from; content; timestamp; seq } -> serialize writer id from content timestamp seq

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor id from content timestamp seq = { id; from; content; timestamp; seq } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun { id; from; content; timestamp; seq } -> serialize id from content timestamp seq
      let from_json_exn =
        let constructor id from content timestamp seq = { id; from; content; timestamp; seq } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end

    and Vote : sig
      type t = {
        id:string;
        topic:string;
        proposer:string;
        options:string list;
        votes:(string * string) list;
        required_votes:int;
        status:string;
        (**
{%html:
<p>&quot;active&quot;, &quot;resolved&quot;</p>
%}
        *)

        result:string;
      }
      val make: ?id:string -> ?topic:string -> ?proposer:string -> ?options:string list -> ?votes:(string * string) list -> ?required_votes:int -> ?status:string -> ?result:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?id:string -> ?topic:string -> ?proposer:string -> ?options:string list -> ?votes:(string * string) list -> ?required_votes:int -> ?status:string -> ?result:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = Vote
      let name () = ".masc.v1.Vote"
      type t = {
        id:string;
        topic:string;
        proposer:string;
        options:string list;
        votes:(string * string) list;
        required_votes:int;
        status:string;
        result:string;
      }
      type make_t = ?id:string -> ?topic:string -> ?proposer:string -> ?options:string list -> ?votes:(string * string) list -> ?required_votes:int -> ?status:string -> ?result:string -> unit -> t
      let make ?(id = {||}) ?(topic = {||}) ?(proposer = {||}) ?(options = []) ?(votes = []) ?(required_votes = 0) ?(status = {||}) ?(result = {||}) () = { id; topic; proposer; options; votes; required_votes; status; result }
      let merge =
      let merge_id = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "id", "id"), string, ({||})) ) in
      let merge_topic = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "topic", "topic"), string, ({||})) ) in
      let merge_proposer = Runtime'.Merge.merge Runtime'.Spec.( basic ((3, "proposer", "proposer"), string, ({||})) ) in
      let merge_options = Runtime'.Merge.merge Runtime'.Spec.( repeated ((4, "options", "options"), string, not_packed) ) in
      let merge_votes = Runtime'.Merge.merge Runtime'.Spec.( map ((5, "votes", "votes"), (string, basic ((2, "value", "value"), string, ({||})))) ) in
      let merge_required_votes = Runtime'.Merge.merge Runtime'.Spec.( basic ((6, "required_votes", "requiredVotes"), int32_int, (0)) ) in
      let merge_status = Runtime'.Merge.merge Runtime'.Spec.( basic ((7, "status", "status"), string, ({||})) ) in
      let merge_result = Runtime'.Merge.merge Runtime'.Spec.( basic ((8, "result", "result"), string, ({||})) ) in
      fun t1 t2 -> {
      	id = (merge_id t1.id t2.id);
      	topic = (merge_topic t1.topic t2.topic);
      	proposer = (merge_proposer t1.proposer t2.proposer);
      	options = (merge_options t1.options t2.options);
      	votes = (merge_votes t1.votes t2.votes);
      	required_votes = (merge_required_votes t1.required_votes t2.required_votes);
      	status = (merge_status t1.status t2.status);
      	result = (merge_result t1.result t2.result);
       }
      let spec () = Runtime'.Spec.( basic ((1, "id", "id"), string, ({||})) ^:: basic ((2, "topic", "topic"), string, ({||})) ^:: basic ((3, "proposer", "proposer"), string, ({||})) ^:: repeated ((4, "options", "options"), string, not_packed) ^:: map ((5, "votes", "votes"), (string, basic ((2, "value", "value"), string, ({||})))) ^:: basic ((6, "required_votes", "requiredVotes"), int32_int, (0)) ^:: basic ((7, "status", "status"), string, ({||})) ^:: basic ((8, "result", "result"), string, ({||})) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer { id; topic; proposer; options; votes; required_votes; status; result } -> serialize writer id topic proposer options votes required_votes status result

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor id topic proposer options votes required_votes status result = { id; topic; proposer; options; votes; required_votes; status; result } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun { id; topic; proposer; options; votes; required_votes; status; result } -> serialize id topic proposer options votes required_votes status result
      let from_json_exn =
        let constructor id topic proposer options votes required_votes status result = { id; topic; proposer; options; votes; required_votes; status; result } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end

    and PlanningContext : sig
      type t = {
        task_id:string;
        task_plan:string;
        notes:string list;
        deliverable:string;
        created_at:string;
        updated_at:string;
      }
      val make: ?task_id:string -> ?task_plan:string -> ?notes:string list -> ?deliverable:string -> ?created_at:string -> ?updated_at:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?task_id:string -> ?task_plan:string -> ?notes:string list -> ?deliverable:string -> ?created_at:string -> ?updated_at:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = PlanningContext
      let name () = ".masc.v1.PlanningContext"
      type t = {
        task_id:string;
        task_plan:string;
        notes:string list;
        deliverable:string;
        created_at:string;
        updated_at:string;
      }
      type make_t = ?task_id:string -> ?task_plan:string -> ?notes:string list -> ?deliverable:string -> ?created_at:string -> ?updated_at:string -> unit -> t
      let make ?(task_id = {||}) ?(task_plan = {||}) ?(notes = []) ?(deliverable = {||}) ?(created_at = {||}) ?(updated_at = {||}) () = { task_id; task_plan; notes; deliverable; created_at; updated_at }
      let merge =
      let merge_task_id = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "task_id", "taskId"), string, ({||})) ) in
      let merge_task_plan = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "task_plan", "taskPlan"), string, ({||})) ) in
      let merge_notes = Runtime'.Merge.merge Runtime'.Spec.( repeated ((3, "notes", "notes"), string, not_packed) ) in
      let merge_deliverable = Runtime'.Merge.merge Runtime'.Spec.( basic ((4, "deliverable", "deliverable"), string, ({||})) ) in
      let merge_created_at = Runtime'.Merge.merge Runtime'.Spec.( basic ((5, "created_at", "createdAt"), string, ({||})) ) in
      let merge_updated_at = Runtime'.Merge.merge Runtime'.Spec.( basic ((6, "updated_at", "updatedAt"), string, ({||})) ) in
      fun t1 t2 -> {
      	task_id = (merge_task_id t1.task_id t2.task_id);
      	task_plan = (merge_task_plan t1.task_plan t2.task_plan);
      	notes = (merge_notes t1.notes t2.notes);
      	deliverable = (merge_deliverable t1.deliverable t2.deliverable);
      	created_at = (merge_created_at t1.created_at t2.created_at);
      	updated_at = (merge_updated_at t1.updated_at t2.updated_at);
       }
      let spec () = Runtime'.Spec.( basic ((1, "task_id", "taskId"), string, ({||})) ^:: basic ((2, "task_plan", "taskPlan"), string, ({||})) ^:: repeated ((3, "notes", "notes"), string, not_packed) ^:: basic ((4, "deliverable", "deliverable"), string, ({||})) ^:: basic ((5, "created_at", "createdAt"), string, ({||})) ^:: basic ((6, "updated_at", "updatedAt"), string, ({||})) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer { task_id; task_plan; notes; deliverable; created_at; updated_at } -> serialize writer task_id task_plan notes deliverable created_at updated_at

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor task_id task_plan notes deliverable created_at updated_at = { task_id; task_plan; notes; deliverable; created_at; updated_at } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun { task_id; task_plan; notes; deliverable; created_at; updated_at } -> serialize task_id task_plan notes deliverable created_at updated_at
      let from_json_exn =
        let constructor task_id task_plan notes deliverable created_at updated_at = { task_id; task_plan; notes; deliverable; created_at; updated_at } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end

    and StatusRequest : sig
      type t = unit
      val make: unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = StatusRequest
      let name () = ".masc.v1.StatusRequest"
      type t = unit
      type make_t = unit -> t
      let make () = ()
      let merge =

      fun () () -> ()
      let spec () = Runtime'.Spec.( nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer () -> serialize writer

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor  = () in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun () -> serialize
      let from_json_exn =
        let constructor  = () in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end

    and StatusResponse : sig
      type t = {
        agents:Agent.t list;
        tasks:Task.t list;
        message_count:int;
        room_path:string;
        project_name:string;
      }
      val make: ?agents:Agent.t list -> ?tasks:Task.t list -> ?message_count:int -> ?room_path:string -> ?project_name:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?agents:Agent.t list -> ?tasks:Task.t list -> ?message_count:int -> ?room_path:string -> ?project_name:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = StatusResponse
      let name () = ".masc.v1.StatusResponse"
      type t = {
        agents:Agent.t list;
        tasks:Task.t list;
        message_count:int;
        room_path:string;
        project_name:string;
      }
      type make_t = ?agents:Agent.t list -> ?tasks:Task.t list -> ?message_count:int -> ?room_path:string -> ?project_name:string -> unit -> t
      let make ?(agents = []) ?(tasks = []) ?(message_count = 0) ?(room_path = {||}) ?(project_name = {||}) () = { agents; tasks; message_count; room_path; project_name }
      let merge =
      let merge_agents = Runtime'.Merge.merge Runtime'.Spec.( repeated ((1, "agents", "agents"), (message (module Agent)), not_packed) ) in
      let merge_tasks = Runtime'.Merge.merge Runtime'.Spec.( repeated ((2, "tasks", "tasks"), (message (module Task)), not_packed) ) in
      let merge_message_count = Runtime'.Merge.merge Runtime'.Spec.( basic ((3, "message_count", "messageCount"), int32_int, (0)) ) in
      let merge_room_path = Runtime'.Merge.merge Runtime'.Spec.( basic ((4, "room_path", "roomPath"), string, ({||})) ) in
      let merge_project_name = Runtime'.Merge.merge Runtime'.Spec.( basic ((5, "project_name", "projectName"), string, ({||})) ) in
      fun t1 t2 -> {
      	agents = (merge_agents t1.agents t2.agents);
      	tasks = (merge_tasks t1.tasks t2.tasks);
      	message_count = (merge_message_count t1.message_count t2.message_count);
      	room_path = (merge_room_path t1.room_path t2.room_path);
      	project_name = (merge_project_name t1.project_name t2.project_name);
       }
      let spec () = Runtime'.Spec.( repeated ((1, "agents", "agents"), (message (module Agent)), not_packed) ^:: repeated ((2, "tasks", "tasks"), (message (module Task)), not_packed) ^:: basic ((3, "message_count", "messageCount"), int32_int, (0)) ^:: basic ((4, "room_path", "roomPath"), string, ({||})) ^:: basic ((5, "project_name", "projectName"), string, ({||})) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer { agents; tasks; message_count; room_path; project_name } -> serialize writer agents tasks message_count room_path project_name

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor agents tasks message_count room_path project_name = { agents; tasks; message_count; room_path; project_name } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun { agents; tasks; message_count; room_path; project_name } -> serialize agents tasks message_count room_path project_name
      let from_json_exn =
        let constructor agents tasks message_count room_path project_name = { agents; tasks; message_count; room_path; project_name } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end

    and JoinRequest : sig
      type t = {
        agent_name:string;
        capabilities:string list;
      }
      val make: ?agent_name:string -> ?capabilities:string list -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?agent_name:string -> ?capabilities:string list -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = JoinRequest
      let name () = ".masc.v1.JoinRequest"
      type t = {
        agent_name:string;
        capabilities:string list;
      }
      type make_t = ?agent_name:string -> ?capabilities:string list -> unit -> t
      let make ?(agent_name = {||}) ?(capabilities = []) () = { agent_name; capabilities }
      let merge =
      let merge_agent_name = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "agent_name", "agentName"), string, ({||})) ) in
      let merge_capabilities = Runtime'.Merge.merge Runtime'.Spec.( repeated ((2, "capabilities", "capabilities"), string, not_packed) ) in
      fun t1 t2 -> {
      	agent_name = (merge_agent_name t1.agent_name t2.agent_name);
      	capabilities = (merge_capabilities t1.capabilities t2.capabilities);
       }
      let spec () = Runtime'.Spec.( basic ((1, "agent_name", "agentName"), string, ({||})) ^:: repeated ((2, "capabilities", "capabilities"), string, not_packed) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer { agent_name; capabilities } -> serialize writer agent_name capabilities

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor agent_name capabilities = { agent_name; capabilities } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun { agent_name; capabilities } -> serialize agent_name capabilities
      let from_json_exn =
        let constructor agent_name capabilities = { agent_name; capabilities } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end

    and JoinResponse : sig
      type t = {
        success:bool;
        message:string;
      }
      val make: ?success:bool -> ?message:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?success:bool -> ?message:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = JoinResponse
      let name () = ".masc.v1.JoinResponse"
      type t = {
        success:bool;
        message:string;
      }
      type make_t = ?success:bool -> ?message:string -> unit -> t
      let make ?(success = false) ?(message = {||}) () = { success; message }
      let merge =
      let merge_success = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "success", "success"), bool, (false)) ) in
      let merge_message = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "message", "message"), string, ({||})) ) in
      fun t1 t2 -> {
      	success = (merge_success t1.success t2.success);
      	message = (merge_message t1.message t2.message);
       }
      let spec () = Runtime'.Spec.( basic ((1, "success", "success"), bool, (false)) ^:: basic ((2, "message", "message"), string, ({||})) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer { success; message } -> serialize writer success message

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor success message = { success; message } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun { success; message } -> serialize success message
      let from_json_exn =
        let constructor success message = { success; message } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end

    and LeaveRequest : sig
      type t = (string)
      val make: ?agent_name:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?agent_name:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = LeaveRequest
      let name () = ".masc.v1.LeaveRequest"
      type t = (string)
      type make_t = ?agent_name:string -> unit -> t
      let make ?(agent_name = {||}) () = (agent_name)
      let merge =
      let merge_agent_name = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "agent_name", "agentName"), string, ({||})) ) in
      fun (t1_agent_name) (t2_agent_name) -> merge_agent_name t1_agent_name t2_agent_name
      let spec () = Runtime'.Spec.( basic ((1, "agent_name", "agentName"), string, ({||})) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer (agent_name) -> serialize writer agent_name

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor agent_name = (agent_name) in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun (agent_name) -> serialize agent_name
      let from_json_exn =
        let constructor agent_name = (agent_name) in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end

    and LeaveResponse : sig
      type t = {
        success:bool;
        message:string;
      }
      val make: ?success:bool -> ?message:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?success:bool -> ?message:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = LeaveResponse
      let name () = ".masc.v1.LeaveResponse"
      type t = {
        success:bool;
        message:string;
      }
      type make_t = ?success:bool -> ?message:string -> unit -> t
      let make ?(success = false) ?(message = {||}) () = { success; message }
      let merge =
      let merge_success = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "success", "success"), bool, (false)) ) in
      let merge_message = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "message", "message"), string, ({||})) ) in
      fun t1 t2 -> {
      	success = (merge_success t1.success t2.success);
      	message = (merge_message t1.message t2.message);
       }
      let spec () = Runtime'.Spec.( basic ((1, "success", "success"), bool, (false)) ^:: basic ((2, "message", "message"), string, ({||})) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer { success; message } -> serialize writer success message

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor success message = { success; message } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun { success; message } -> serialize success message
      let from_json_exn =
        let constructor success message = { success; message } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end

    and AddTaskRequest : sig
      type t = {
        title:string;
        description:string;
        priority:int;
      }
      val make: ?title:string -> ?description:string -> ?priority:int -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?title:string -> ?description:string -> ?priority:int -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = AddTaskRequest
      let name () = ".masc.v1.AddTaskRequest"
      type t = {
        title:string;
        description:string;
        priority:int;
      }
      type make_t = ?title:string -> ?description:string -> ?priority:int -> unit -> t
      let make ?(title = {||}) ?(description = {||}) ?(priority = 0) () = { title; description; priority }
      let merge =
      let merge_title = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "title", "title"), string, ({||})) ) in
      let merge_description = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "description", "description"), string, ({||})) ) in
      let merge_priority = Runtime'.Merge.merge Runtime'.Spec.( basic ((3, "priority", "priority"), int32_int, (0)) ) in
      fun t1 t2 -> {
      	title = (merge_title t1.title t2.title);
      	description = (merge_description t1.description t2.description);
      	priority = (merge_priority t1.priority t2.priority);
       }
      let spec () = Runtime'.Spec.( basic ((1, "title", "title"), string, ({||})) ^:: basic ((2, "description", "description"), string, ({||})) ^:: basic ((3, "priority", "priority"), int32_int, (0)) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer { title; description; priority } -> serialize writer title description priority

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor title description priority = { title; description; priority } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun { title; description; priority } -> serialize title description priority
      let from_json_exn =
        let constructor title description priority = { title; description; priority } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end

    and AddTaskResponse : sig
      type t = {
        success:bool;
        task_id:string;
        message:string;
      }
      val make: ?success:bool -> ?task_id:string -> ?message:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?success:bool -> ?task_id:string -> ?message:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = AddTaskResponse
      let name () = ".masc.v1.AddTaskResponse"
      type t = {
        success:bool;
        task_id:string;
        message:string;
      }
      type make_t = ?success:bool -> ?task_id:string -> ?message:string -> unit -> t
      let make ?(success = false) ?(task_id = {||}) ?(message = {||}) () = { success; task_id; message }
      let merge =
      let merge_success = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "success", "success"), bool, (false)) ) in
      let merge_task_id = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "task_id", "taskId"), string, ({||})) ) in
      let merge_message = Runtime'.Merge.merge Runtime'.Spec.( basic ((3, "message", "message"), string, ({||})) ) in
      fun t1 t2 -> {
      	success = (merge_success t1.success t2.success);
      	task_id = (merge_task_id t1.task_id t2.task_id);
      	message = (merge_message t1.message t2.message);
       }
      let spec () = Runtime'.Spec.( basic ((1, "success", "success"), bool, (false)) ^:: basic ((2, "task_id", "taskId"), string, ({||})) ^:: basic ((3, "message", "message"), string, ({||})) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer { success; task_id; message } -> serialize writer success task_id message

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor success task_id message = { success; task_id; message } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun { success; task_id; message } -> serialize success task_id message
      let from_json_exn =
        let constructor success task_id message = { success; task_id; message } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end

    and ClaimTaskRequest : sig
      type t = {
        agent_name:string;
        task_id:string;
      }
      val make: ?agent_name:string -> ?task_id:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?agent_name:string -> ?task_id:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = ClaimTaskRequest
      let name () = ".masc.v1.ClaimTaskRequest"
      type t = {
        agent_name:string;
        task_id:string;
      }
      type make_t = ?agent_name:string -> ?task_id:string -> unit -> t
      let make ?(agent_name = {||}) ?(task_id = {||}) () = { agent_name; task_id }
      let merge =
      let merge_agent_name = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "agent_name", "agentName"), string, ({||})) ) in
      let merge_task_id = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "task_id", "taskId"), string, ({||})) ) in
      fun t1 t2 -> {
      	agent_name = (merge_agent_name t1.agent_name t2.agent_name);
      	task_id = (merge_task_id t1.task_id t2.task_id);
       }
      let spec () = Runtime'.Spec.( basic ((1, "agent_name", "agentName"), string, ({||})) ^:: basic ((2, "task_id", "taskId"), string, ({||})) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer { agent_name; task_id } -> serialize writer agent_name task_id

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor agent_name task_id = { agent_name; task_id } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun { agent_name; task_id } -> serialize agent_name task_id
      let from_json_exn =
        let constructor agent_name task_id = { agent_name; task_id } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end

    and ClaimTaskResponse : sig
      type t = {
        success:bool;
        message:string;
      }
      val make: ?success:bool -> ?message:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?success:bool -> ?message:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = ClaimTaskResponse
      let name () = ".masc.v1.ClaimTaskResponse"
      type t = {
        success:bool;
        message:string;
      }
      type make_t = ?success:bool -> ?message:string -> unit -> t
      let make ?(success = false) ?(message = {||}) () = { success; message }
      let merge =
      let merge_success = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "success", "success"), bool, (false)) ) in
      let merge_message = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "message", "message"), string, ({||})) ) in
      fun t1 t2 -> {
      	success = (merge_success t1.success t2.success);
      	message = (merge_message t1.message t2.message);
       }
      let spec () = Runtime'.Spec.( basic ((1, "success", "success"), bool, (false)) ^:: basic ((2, "message", "message"), string, ({||})) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer { success; message } -> serialize writer success message

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor success message = { success; message } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun { success; message } -> serialize success message
      let from_json_exn =
        let constructor success message = { success; message } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end

    and DoneTaskRequest : sig
      type t = {
        agent_name:string;
        task_id:string;
        notes:string;
      }
      val make: ?agent_name:string -> ?task_id:string -> ?notes:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?agent_name:string -> ?task_id:string -> ?notes:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = DoneTaskRequest
      let name () = ".masc.v1.DoneTaskRequest"
      type t = {
        agent_name:string;
        task_id:string;
        notes:string;
      }
      type make_t = ?agent_name:string -> ?task_id:string -> ?notes:string -> unit -> t
      let make ?(agent_name = {||}) ?(task_id = {||}) ?(notes = {||}) () = { agent_name; task_id; notes }
      let merge =
      let merge_agent_name = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "agent_name", "agentName"), string, ({||})) ) in
      let merge_task_id = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "task_id", "taskId"), string, ({||})) ) in
      let merge_notes = Runtime'.Merge.merge Runtime'.Spec.( basic ((3, "notes", "notes"), string, ({||})) ) in
      fun t1 t2 -> {
      	agent_name = (merge_agent_name t1.agent_name t2.agent_name);
      	task_id = (merge_task_id t1.task_id t2.task_id);
      	notes = (merge_notes t1.notes t2.notes);
       }
      let spec () = Runtime'.Spec.( basic ((1, "agent_name", "agentName"), string, ({||})) ^:: basic ((2, "task_id", "taskId"), string, ({||})) ^:: basic ((3, "notes", "notes"), string, ({||})) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer { agent_name; task_id; notes } -> serialize writer agent_name task_id notes

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor agent_name task_id notes = { agent_name; task_id; notes } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun { agent_name; task_id; notes } -> serialize agent_name task_id notes
      let from_json_exn =
        let constructor agent_name task_id notes = { agent_name; task_id; notes } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end

    and DoneTaskResponse : sig
      type t = {
        success:bool;
        message:string;
      }
      val make: ?success:bool -> ?message:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?success:bool -> ?message:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = DoneTaskResponse
      let name () = ".masc.v1.DoneTaskResponse"
      type t = {
        success:bool;
        message:string;
      }
      type make_t = ?success:bool -> ?message:string -> unit -> t
      let make ?(success = false) ?(message = {||}) () = { success; message }
      let merge =
      let merge_success = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "success", "success"), bool, (false)) ) in
      let merge_message = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "message", "message"), string, ({||})) ) in
      fun t1 t2 -> {
      	success = (merge_success t1.success t2.success);
      	message = (merge_message t1.message t2.message);
       }
      let spec () = Runtime'.Spec.( basic ((1, "success", "success"), bool, (false)) ^:: basic ((2, "message", "message"), string, ({||})) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer { success; message } -> serialize writer success message

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor success message = { success; message } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun { success; message } -> serialize success message
      let from_json_exn =
        let constructor success message = { success; message } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end

    and CancelTaskRequest : sig
      type t = {
        agent_name:string;
        task_id:string;
        reason:string;
      }
      val make: ?agent_name:string -> ?task_id:string -> ?reason:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?agent_name:string -> ?task_id:string -> ?reason:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = CancelTaskRequest
      let name () = ".masc.v1.CancelTaskRequest"
      type t = {
        agent_name:string;
        task_id:string;
        reason:string;
      }
      type make_t = ?agent_name:string -> ?task_id:string -> ?reason:string -> unit -> t
      let make ?(agent_name = {||}) ?(task_id = {||}) ?(reason = {||}) () = { agent_name; task_id; reason }
      let merge =
      let merge_agent_name = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "agent_name", "agentName"), string, ({||})) ) in
      let merge_task_id = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "task_id", "taskId"), string, ({||})) ) in
      let merge_reason = Runtime'.Merge.merge Runtime'.Spec.( basic ((3, "reason", "reason"), string, ({||})) ) in
      fun t1 t2 -> {
      	agent_name = (merge_agent_name t1.agent_name t2.agent_name);
      	task_id = (merge_task_id t1.task_id t2.task_id);
      	reason = (merge_reason t1.reason t2.reason);
       }
      let spec () = Runtime'.Spec.( basic ((1, "agent_name", "agentName"), string, ({||})) ^:: basic ((2, "task_id", "taskId"), string, ({||})) ^:: basic ((3, "reason", "reason"), string, ({||})) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer { agent_name; task_id; reason } -> serialize writer agent_name task_id reason

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor agent_name task_id reason = { agent_name; task_id; reason } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun { agent_name; task_id; reason } -> serialize agent_name task_id reason
      let from_json_exn =
        let constructor agent_name task_id reason = { agent_name; task_id; reason } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end

    and CancelTaskResponse : sig
      type t = {
        success:bool;
        message:string;
      }
      val make: ?success:bool -> ?message:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?success:bool -> ?message:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = CancelTaskResponse
      let name () = ".masc.v1.CancelTaskResponse"
      type t = {
        success:bool;
        message:string;
      }
      type make_t = ?success:bool -> ?message:string -> unit -> t
      let make ?(success = false) ?(message = {||}) () = { success; message }
      let merge =
      let merge_success = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "success", "success"), bool, (false)) ) in
      let merge_message = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "message", "message"), string, ({||})) ) in
      fun t1 t2 -> {
      	success = (merge_success t1.success t2.success);
      	message = (merge_message t1.message t2.message);
       }
      let spec () = Runtime'.Spec.( basic ((1, "success", "success"), bool, (false)) ^:: basic ((2, "message", "message"), string, ({||})) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer { success; message } -> serialize writer success message

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor success message = { success; message } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun { success; message } -> serialize success message
      let from_json_exn =
        let constructor success message = { success; message } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end

    and BroadcastRequest : sig
      type t = {
        agent_name:string;
        message:string;
      }
      val make: ?agent_name:string -> ?message:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?agent_name:string -> ?message:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = BroadcastRequest
      let name () = ".masc.v1.BroadcastRequest"
      type t = {
        agent_name:string;
        message:string;
      }
      type make_t = ?agent_name:string -> ?message:string -> unit -> t
      let make ?(agent_name = {||}) ?(message = {||}) () = { agent_name; message }
      let merge =
      let merge_agent_name = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "agent_name", "agentName"), string, ({||})) ) in
      let merge_message = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "message", "message"), string, ({||})) ) in
      fun t1 t2 -> {
      	agent_name = (merge_agent_name t1.agent_name t2.agent_name);
      	message = (merge_message t1.message t2.message);
       }
      let spec () = Runtime'.Spec.( basic ((1, "agent_name", "agentName"), string, ({||})) ^:: basic ((2, "message", "message"), string, ({||})) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer { agent_name; message } -> serialize writer agent_name message

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor agent_name message = { agent_name; message } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun { agent_name; message } -> serialize agent_name message
      let from_json_exn =
        let constructor agent_name message = { agent_name; message } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end

    and BroadcastResponse : sig
      type t = {
        success:bool;
        seq:int;
      }
      val make: ?success:bool -> ?seq:int -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?success:bool -> ?seq:int -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = BroadcastResponse
      let name () = ".masc.v1.BroadcastResponse"
      type t = {
        success:bool;
        seq:int;
      }
      type make_t = ?success:bool -> ?seq:int -> unit -> t
      let make ?(success = false) ?(seq = 0) () = { success; seq }
      let merge =
      let merge_success = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "success", "success"), bool, (false)) ) in
      let merge_seq = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "seq", "seq"), int64_int, (0)) ) in
      fun t1 t2 -> {
      	success = (merge_success t1.success t2.success);
      	seq = (merge_seq t1.seq t2.seq);
       }
      let spec () = Runtime'.Spec.( basic ((1, "success", "success"), bool, (false)) ^:: basic ((2, "seq", "seq"), int64_int, (0)) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer { success; seq } -> serialize writer success seq

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor success seq = { success; seq } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun { success; seq } -> serialize success seq
      let from_json_exn =
        let constructor success seq = { success; seq } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end

    and GetMessagesRequest : sig
      type t = {
        since_seq:int;
        limit:int;
      }
      val make: ?since_seq:int -> ?limit:int -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?since_seq:int -> ?limit:int -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = GetMessagesRequest
      let name () = ".masc.v1.GetMessagesRequest"
      type t = {
        since_seq:int;
        limit:int;
      }
      type make_t = ?since_seq:int -> ?limit:int -> unit -> t
      let make ?(since_seq = 0) ?(limit = 0) () = { since_seq; limit }
      let merge =
      let merge_since_seq = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "since_seq", "sinceSeq"), int64_int, (0)) ) in
      let merge_limit = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "limit", "limit"), int32_int, (0)) ) in
      fun t1 t2 -> {
      	since_seq = (merge_since_seq t1.since_seq t2.since_seq);
      	limit = (merge_limit t1.limit t2.limit);
       }
      let spec () = Runtime'.Spec.( basic ((1, "since_seq", "sinceSeq"), int64_int, (0)) ^:: basic ((2, "limit", "limit"), int32_int, (0)) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer { since_seq; limit } -> serialize writer since_seq limit

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor since_seq limit = { since_seq; limit } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun { since_seq; limit } -> serialize since_seq limit
      let from_json_exn =
        let constructor since_seq limit = { since_seq; limit } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end

    and GetMessagesResponse : sig
      type t = (Message.t list)
      val make: ?messages:Message.t list -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?messages:Message.t list -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = GetMessagesResponse
      let name () = ".masc.v1.GetMessagesResponse"
      type t = (Message.t list)
      type make_t = ?messages:Message.t list -> unit -> t
      let make ?(messages = []) () = (messages)
      let merge =
      let merge_messages = Runtime'.Merge.merge Runtime'.Spec.( repeated ((1, "messages", "messages"), (message (module Message)), not_packed) ) in
      fun (t1_messages) (t2_messages) -> merge_messages t1_messages t2_messages
      let spec () = Runtime'.Spec.( repeated ((1, "messages", "messages"), (message (module Message)), not_packed) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer (messages) -> serialize writer messages

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor messages = (messages) in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun (messages) -> serialize messages
      let from_json_exn =
        let constructor messages = (messages) in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end

    and CreateVoteRequest : sig
      type t = {
        proposer:string;
        topic:string;
        options:string list;
        required_votes:int;
      }
      val make: ?proposer:string -> ?topic:string -> ?options:string list -> ?required_votes:int -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?proposer:string -> ?topic:string -> ?options:string list -> ?required_votes:int -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = CreateVoteRequest
      let name () = ".masc.v1.CreateVoteRequest"
      type t = {
        proposer:string;
        topic:string;
        options:string list;
        required_votes:int;
      }
      type make_t = ?proposer:string -> ?topic:string -> ?options:string list -> ?required_votes:int -> unit -> t
      let make ?(proposer = {||}) ?(topic = {||}) ?(options = []) ?(required_votes = 0) () = { proposer; topic; options; required_votes }
      let merge =
      let merge_proposer = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "proposer", "proposer"), string, ({||})) ) in
      let merge_topic = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "topic", "topic"), string, ({||})) ) in
      let merge_options = Runtime'.Merge.merge Runtime'.Spec.( repeated ((3, "options", "options"), string, not_packed) ) in
      let merge_required_votes = Runtime'.Merge.merge Runtime'.Spec.( basic ((4, "required_votes", "requiredVotes"), int32_int, (0)) ) in
      fun t1 t2 -> {
      	proposer = (merge_proposer t1.proposer t2.proposer);
      	topic = (merge_topic t1.topic t2.topic);
      	options = (merge_options t1.options t2.options);
      	required_votes = (merge_required_votes t1.required_votes t2.required_votes);
       }
      let spec () = Runtime'.Spec.( basic ((1, "proposer", "proposer"), string, ({||})) ^:: basic ((2, "topic", "topic"), string, ({||})) ^:: repeated ((3, "options", "options"), string, not_packed) ^:: basic ((4, "required_votes", "requiredVotes"), int32_int, (0)) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer { proposer; topic; options; required_votes } -> serialize writer proposer topic options required_votes

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor proposer topic options required_votes = { proposer; topic; options; required_votes } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun { proposer; topic; options; required_votes } -> serialize proposer topic options required_votes
      let from_json_exn =
        let constructor proposer topic options required_votes = { proposer; topic; options; required_votes } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end

    and CreateVoteResponse : sig
      type t = {
        success:bool;
        vote_id:string;
      }
      val make: ?success:bool -> ?vote_id:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?success:bool -> ?vote_id:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = CreateVoteResponse
      let name () = ".masc.v1.CreateVoteResponse"
      type t = {
        success:bool;
        vote_id:string;
      }
      type make_t = ?success:bool -> ?vote_id:string -> unit -> t
      let make ?(success = false) ?(vote_id = {||}) () = { success; vote_id }
      let merge =
      let merge_success = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "success", "success"), bool, (false)) ) in
      let merge_vote_id = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "vote_id", "voteId"), string, ({||})) ) in
      fun t1 t2 -> {
      	success = (merge_success t1.success t2.success);
      	vote_id = (merge_vote_id t1.vote_id t2.vote_id);
       }
      let spec () = Runtime'.Spec.( basic ((1, "success", "success"), bool, (false)) ^:: basic ((2, "vote_id", "voteId"), string, ({||})) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer { success; vote_id } -> serialize writer success vote_id

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor success vote_id = { success; vote_id } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun { success; vote_id } -> serialize success vote_id
      let from_json_exn =
        let constructor success vote_id = { success; vote_id } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end

    and CastVoteRequest : sig
      type t = {
        agent_name:string;
        vote_id:string;
        choice:string;
      }
      val make: ?agent_name:string -> ?vote_id:string -> ?choice:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?agent_name:string -> ?vote_id:string -> ?choice:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = CastVoteRequest
      let name () = ".masc.v1.CastVoteRequest"
      type t = {
        agent_name:string;
        vote_id:string;
        choice:string;
      }
      type make_t = ?agent_name:string -> ?vote_id:string -> ?choice:string -> unit -> t
      let make ?(agent_name = {||}) ?(vote_id = {||}) ?(choice = {||}) () = { agent_name; vote_id; choice }
      let merge =
      let merge_agent_name = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "agent_name", "agentName"), string, ({||})) ) in
      let merge_vote_id = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "vote_id", "voteId"), string, ({||})) ) in
      let merge_choice = Runtime'.Merge.merge Runtime'.Spec.( basic ((3, "choice", "choice"), string, ({||})) ) in
      fun t1 t2 -> {
      	agent_name = (merge_agent_name t1.agent_name t2.agent_name);
      	vote_id = (merge_vote_id t1.vote_id t2.vote_id);
      	choice = (merge_choice t1.choice t2.choice);
       }
      let spec () = Runtime'.Spec.( basic ((1, "agent_name", "agentName"), string, ({||})) ^:: basic ((2, "vote_id", "voteId"), string, ({||})) ^:: basic ((3, "choice", "choice"), string, ({||})) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer { agent_name; vote_id; choice } -> serialize writer agent_name vote_id choice

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor agent_name vote_id choice = { agent_name; vote_id; choice } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun { agent_name; vote_id; choice } -> serialize agent_name vote_id choice
      let from_json_exn =
        let constructor agent_name vote_id choice = { agent_name; vote_id; choice } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end

    and CastVoteResponse : sig
      type t = {
        success:bool;
        message:string;
        status:string;
        result:string;
      }
      val make: ?success:bool -> ?message:string -> ?status:string -> ?result:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?success:bool -> ?message:string -> ?status:string -> ?result:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = CastVoteResponse
      let name () = ".masc.v1.CastVoteResponse"
      type t = {
        success:bool;
        message:string;
        status:string;
        result:string;
      }
      type make_t = ?success:bool -> ?message:string -> ?status:string -> ?result:string -> unit -> t
      let make ?(success = false) ?(message = {||}) ?(status = {||}) ?(result = {||}) () = { success; message; status; result }
      let merge =
      let merge_success = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "success", "success"), bool, (false)) ) in
      let merge_message = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "message", "message"), string, ({||})) ) in
      let merge_status = Runtime'.Merge.merge Runtime'.Spec.( basic ((3, "status", "status"), string, ({||})) ) in
      let merge_result = Runtime'.Merge.merge Runtime'.Spec.( basic ((4, "result", "result"), string, ({||})) ) in
      fun t1 t2 -> {
      	success = (merge_success t1.success t2.success);
      	message = (merge_message t1.message t2.message);
      	status = (merge_status t1.status t2.status);
      	result = (merge_result t1.result t2.result);
       }
      let spec () = Runtime'.Spec.( basic ((1, "success", "success"), bool, (false)) ^:: basic ((2, "message", "message"), string, ({||})) ^:: basic ((3, "status", "status"), string, ({||})) ^:: basic ((4, "result", "result"), string, ({||})) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer { success; message; status; result } -> serialize writer success message status result

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor success message status result = { success; message; status; result } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun { success; message; status; result } -> serialize success message status result
      let from_json_exn =
        let constructor success message status result = { success; message; status; result } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end

    and InitPlanRequest : sig
      type t = (string)
      val make: ?task_id:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?task_id:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = InitPlanRequest
      let name () = ".masc.v1.InitPlanRequest"
      type t = (string)
      type make_t = ?task_id:string -> unit -> t
      let make ?(task_id = {||}) () = (task_id)
      let merge =
      let merge_task_id = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "task_id", "taskId"), string, ({||})) ) in
      fun (t1_task_id) (t2_task_id) -> merge_task_id t1_task_id t2_task_id
      let spec () = Runtime'.Spec.( basic ((1, "task_id", "taskId"), string, ({||})) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer (task_id) -> serialize writer task_id

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor task_id = (task_id) in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun (task_id) -> serialize task_id
      let from_json_exn =
        let constructor task_id = (task_id) in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end

    and InitPlanResponse : sig
      type t = {
        success:bool;
        context:PlanningContext.t option;
      }
      val make: ?success:bool -> ?context:PlanningContext.t -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?success:bool -> ?context:PlanningContext.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = InitPlanResponse
      let name () = ".masc.v1.InitPlanResponse"
      type t = {
        success:bool;
        context:PlanningContext.t option;
      }
      type make_t = ?success:bool -> ?context:PlanningContext.t -> unit -> t
      let make ?(success = false) ?context () = { success; context }
      let merge =
      let merge_success = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "success", "success"), bool, (false)) ) in
      let merge_context = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((2, "context", "context"), (message (module PlanningContext))) ) in
      fun t1 t2 -> {
      	success = (merge_success t1.success t2.success);
      	context = (merge_context t1.context t2.context);
       }
      let spec () = Runtime'.Spec.( basic ((1, "success", "success"), bool, (false)) ^:: basic_opt ((2, "context", "context"), (message (module PlanningContext))) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer { success; context } -> serialize writer success context

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor success context = { success; context } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun { success; context } -> serialize success context
      let from_json_exn =
        let constructor success context = { success; context } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end

    and UpdatePlanRequest : sig
      type t = {
        task_id:string;
        content:string;
      }
      val make: ?task_id:string -> ?content:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?task_id:string -> ?content:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = UpdatePlanRequest
      let name () = ".masc.v1.UpdatePlanRequest"
      type t = {
        task_id:string;
        content:string;
      }
      type make_t = ?task_id:string -> ?content:string -> unit -> t
      let make ?(task_id = {||}) ?(content = {||}) () = { task_id; content }
      let merge =
      let merge_task_id = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "task_id", "taskId"), string, ({||})) ) in
      let merge_content = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "content", "content"), string, ({||})) ) in
      fun t1 t2 -> {
      	task_id = (merge_task_id t1.task_id t2.task_id);
      	content = (merge_content t1.content t2.content);
       }
      let spec () = Runtime'.Spec.( basic ((1, "task_id", "taskId"), string, ({||})) ^:: basic ((2, "content", "content"), string, ({||})) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer { task_id; content } -> serialize writer task_id content

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor task_id content = { task_id; content } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun { task_id; content } -> serialize task_id content
      let from_json_exn =
        let constructor task_id content = { task_id; content } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end

    and UpdatePlanResponse : sig
      type t = {
        success:bool;
        context:PlanningContext.t option;
      }
      val make: ?success:bool -> ?context:PlanningContext.t -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?success:bool -> ?context:PlanningContext.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = UpdatePlanResponse
      let name () = ".masc.v1.UpdatePlanResponse"
      type t = {
        success:bool;
        context:PlanningContext.t option;
      }
      type make_t = ?success:bool -> ?context:PlanningContext.t -> unit -> t
      let make ?(success = false) ?context () = { success; context }
      let merge =
      let merge_success = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "success", "success"), bool, (false)) ) in
      let merge_context = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((2, "context", "context"), (message (module PlanningContext))) ) in
      fun t1 t2 -> {
      	success = (merge_success t1.success t2.success);
      	context = (merge_context t1.context t2.context);
       }
      let spec () = Runtime'.Spec.( basic ((1, "success", "success"), bool, (false)) ^:: basic_opt ((2, "context", "context"), (message (module PlanningContext))) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer { success; context } -> serialize writer success context

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor success context = { success; context } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun { success; context } -> serialize success context
      let from_json_exn =
        let constructor success context = { success; context } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end

    and AddNoteRequest : sig
      type t = {
        task_id:string;
        note:string;
      }
      val make: ?task_id:string -> ?note:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?task_id:string -> ?note:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = AddNoteRequest
      let name () = ".masc.v1.AddNoteRequest"
      type t = {
        task_id:string;
        note:string;
      }
      type make_t = ?task_id:string -> ?note:string -> unit -> t
      let make ?(task_id = {||}) ?(note = {||}) () = { task_id; note }
      let merge =
      let merge_task_id = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "task_id", "taskId"), string, ({||})) ) in
      let merge_note = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "note", "note"), string, ({||})) ) in
      fun t1 t2 -> {
      	task_id = (merge_task_id t1.task_id t2.task_id);
      	note = (merge_note t1.note t2.note);
       }
      let spec () = Runtime'.Spec.( basic ((1, "task_id", "taskId"), string, ({||})) ^:: basic ((2, "note", "note"), string, ({||})) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer { task_id; note } -> serialize writer task_id note

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor task_id note = { task_id; note } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun { task_id; note } -> serialize task_id note
      let from_json_exn =
        let constructor task_id note = { task_id; note } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end

    and AddNoteResponse : sig
      type t = {
        success:bool;
        context:PlanningContext.t option;
      }
      val make: ?success:bool -> ?context:PlanningContext.t -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?success:bool -> ?context:PlanningContext.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = AddNoteResponse
      let name () = ".masc.v1.AddNoteResponse"
      type t = {
        success:bool;
        context:PlanningContext.t option;
      }
      type make_t = ?success:bool -> ?context:PlanningContext.t -> unit -> t
      let make ?(success = false) ?context () = { success; context }
      let merge =
      let merge_success = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "success", "success"), bool, (false)) ) in
      let merge_context = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((2, "context", "context"), (message (module PlanningContext))) ) in
      fun t1 t2 -> {
      	success = (merge_success t1.success t2.success);
      	context = (merge_context t1.context t2.context);
       }
      let spec () = Runtime'.Spec.( basic ((1, "success", "success"), bool, (false)) ^:: basic_opt ((2, "context", "context"), (message (module PlanningContext))) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer { success; context } -> serialize writer success context

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor success context = { success; context } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun { success; context } -> serialize success context
      let from_json_exn =
        let constructor success context = { success; context } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end

    and GetPlanRequest : sig
      type t = (string)
      val make: ?task_id:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?task_id:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = GetPlanRequest
      let name () = ".masc.v1.GetPlanRequest"
      type t = (string)
      type make_t = ?task_id:string -> unit -> t
      let make ?(task_id = {||}) () = (task_id)
      let merge =
      let merge_task_id = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "task_id", "taskId"), string, ({||})) ) in
      fun (t1_task_id) (t2_task_id) -> merge_task_id t1_task_id t2_task_id
      let spec () = Runtime'.Spec.( basic ((1, "task_id", "taskId"), string, ({||})) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer (task_id) -> serialize writer task_id

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor task_id = (task_id) in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun (task_id) -> serialize task_id
      let from_json_exn =
        let constructor task_id = (task_id) in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end

    and GetPlanResponse : sig
      type t = {
        success:bool;
        context:PlanningContext.t option;
        markdown:string;
        (**
{%html:
<p>Formatted for LLM consumption</p>
%}
        *)

      }
      val make: ?success:bool -> ?context:PlanningContext.t -> ?markdown:string -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?success:bool -> ?context:PlanningContext.t -> ?markdown:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = GetPlanResponse
      let name () = ".masc.v1.GetPlanResponse"
      type t = {
        success:bool;
        context:PlanningContext.t option;
        markdown:string;
      }
      type make_t = ?success:bool -> ?context:PlanningContext.t -> ?markdown:string -> unit -> t
      let make ?(success = false) ?context ?(markdown = {||}) () = { success; context; markdown }
      let merge =
      let merge_success = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "success", "success"), bool, (false)) ) in
      let merge_context = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((2, "context", "context"), (message (module PlanningContext))) ) in
      let merge_markdown = Runtime'.Merge.merge Runtime'.Spec.( basic ((3, "markdown", "markdown"), string, ({||})) ) in
      fun t1 t2 -> {
      	success = (merge_success t1.success t2.success);
      	context = (merge_context t1.context t2.context);
      	markdown = (merge_markdown t1.markdown t2.markdown);
       }
      let spec () = Runtime'.Spec.( basic ((1, "success", "success"), bool, (false)) ^:: basic_opt ((2, "context", "context"), (message (module PlanningContext))) ^:: basic ((3, "markdown", "markdown"), string, ({||})) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer { success; context; markdown } -> serialize writer success context markdown

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor success context markdown = { success; context; markdown } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun { success; context; markdown } -> serialize success context markdown
      let from_json_exn =
        let constructor success context markdown = { success; context; markdown } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end

    and StreamMessagesRequest : sig
      type t = {
        agent_name:string;
        since_seq:int;
      }
      val make: ?agent_name:string -> ?since_seq:int -> unit -> t
      (** Helper function to generate a message using default values *)

      val to_proto: t -> Runtime'.Writer.t
      (** Serialize the message to binary format *)

      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from binary format *)

      val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
      (** Serialize to Json (compatible with Yojson.Basic.t) *)

      val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
      (** Deserialize from Json (compatible with Yojson.Basic.t) *)

      val name: unit -> string
      (** Fully qualified protobuf name of this message *)

      (**/**)
      type make_t = ?agent_name:string -> ?since_seq:int -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> unit
      val from_proto_exn: Runtime'.Reader.t -> t
      val from_json_exn: Runtime'.Json.t -> t
      (**/**)
    end = struct
      module This'_ = StreamMessagesRequest
      let name () = ".masc.v1.StreamMessagesRequest"
      type t = {
        agent_name:string;
        since_seq:int;
      }
      type make_t = ?agent_name:string -> ?since_seq:int -> unit -> t
      let make ?(agent_name = {||}) ?(since_seq = 0) () = { agent_name; since_seq }
      let merge =
      let merge_agent_name = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "agent_name", "agentName"), string, ({||})) ) in
      let merge_since_seq = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "since_seq", "sinceSeq"), int64_int, (0)) ) in
      fun t1 t2 -> {
      	agent_name = (merge_agent_name t1.agent_name t2.agent_name);
      	since_seq = (merge_since_seq t1.since_seq t2.since_seq);
       }
      let spec () = Runtime'.Spec.( basic ((1, "agent_name", "agentName"), string, ({||})) ^:: basic ((2, "since_seq", "sinceSeq"), int64_int, (0)) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
        fun writer { agent_name; since_seq } -> serialize writer agent_name since_seq

      let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
      let from_proto_exn =
        let constructor agent_name since_seq = { agent_name; since_seq } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json options =
        let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
        fun { agent_name; since_seq } -> serialize agent_name since_seq
      let from_json_exn =
        let constructor agent_name since_seq = { agent_name; since_seq } in
        Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end

    module MASCService = struct
      module GetStatus = struct
        let package_name = Some "masc.v1"
        let service_name = "MASCService"
        let method_name = "GetStatus"
        let name = "/masc.v1.MASCService/GetStatus"
        module Request = StatusRequest
        module Response = StatusResponse
      end

      let getStatus =
        (module StatusRequest : Runtime'.Spec.Message with type t = StatusRequest.t ),
        (module StatusResponse : Runtime'.Spec.Message with type t = StatusResponse.t )

      module Join = struct
        let package_name = Some "masc.v1"
        let service_name = "MASCService"
        let method_name = "Join"
        let name = "/masc.v1.MASCService/Join"
        module Request = JoinRequest
        module Response = JoinResponse
      end

      let join =
        (module JoinRequest : Runtime'.Spec.Message with type t = JoinRequest.t ),
        (module JoinResponse : Runtime'.Spec.Message with type t = JoinResponse.t )

      module Leave = struct
        let package_name = Some "masc.v1"
        let service_name = "MASCService"
        let method_name = "Leave"
        let name = "/masc.v1.MASCService/Leave"
        module Request = LeaveRequest
        module Response = LeaveResponse
      end

      let leave =
        (module LeaveRequest : Runtime'.Spec.Message with type t = LeaveRequest.t ),
        (module LeaveResponse : Runtime'.Spec.Message with type t = LeaveResponse.t )

      module AddTask = struct
        let package_name = Some "masc.v1"
        let service_name = "MASCService"
        let method_name = "AddTask"
        let name = "/masc.v1.MASCService/AddTask"
        module Request = AddTaskRequest
        module Response = AddTaskResponse
      end

      let addTask =
        (module AddTaskRequest : Runtime'.Spec.Message with type t = AddTaskRequest.t ),
        (module AddTaskResponse : Runtime'.Spec.Message with type t = AddTaskResponse.t )

      module ClaimTask = struct
        let package_name = Some "masc.v1"
        let service_name = "MASCService"
        let method_name = "ClaimTask"
        let name = "/masc.v1.MASCService/ClaimTask"
        module Request = ClaimTaskRequest
        module Response = ClaimTaskResponse
      end

      let claimTask =
        (module ClaimTaskRequest : Runtime'.Spec.Message with type t = ClaimTaskRequest.t ),
        (module ClaimTaskResponse : Runtime'.Spec.Message with type t = ClaimTaskResponse.t )

      module DoneTask = struct
        let package_name = Some "masc.v1"
        let service_name = "MASCService"
        let method_name = "DoneTask"
        let name = "/masc.v1.MASCService/DoneTask"
        module Request = DoneTaskRequest
        module Response = DoneTaskResponse
      end

      let doneTask =
        (module DoneTaskRequest : Runtime'.Spec.Message with type t = DoneTaskRequest.t ),
        (module DoneTaskResponse : Runtime'.Spec.Message with type t = DoneTaskResponse.t )

      module CancelTask = struct
        let package_name = Some "masc.v1"
        let service_name = "MASCService"
        let method_name = "CancelTask"
        let name = "/masc.v1.MASCService/CancelTask"
        module Request = CancelTaskRequest
        module Response = CancelTaskResponse
      end

      let cancelTask =
        (module CancelTaskRequest : Runtime'.Spec.Message with type t = CancelTaskRequest.t ),
        (module CancelTaskResponse : Runtime'.Spec.Message with type t = CancelTaskResponse.t )

      module Broadcast = struct
        let package_name = Some "masc.v1"
        let service_name = "MASCService"
        let method_name = "Broadcast"
        let name = "/masc.v1.MASCService/Broadcast"
        module Request = BroadcastRequest
        module Response = BroadcastResponse
      end

      let broadcast =
        (module BroadcastRequest : Runtime'.Spec.Message with type t = BroadcastRequest.t ),
        (module BroadcastResponse : Runtime'.Spec.Message with type t = BroadcastResponse.t )

      module GetMessages = struct
        let package_name = Some "masc.v1"
        let service_name = "MASCService"
        let method_name = "GetMessages"
        let name = "/masc.v1.MASCService/GetMessages"
        module Request = GetMessagesRequest
        module Response = GetMessagesResponse
      end

      let getMessages =
        (module GetMessagesRequest : Runtime'.Spec.Message with type t = GetMessagesRequest.t ),
        (module GetMessagesResponse : Runtime'.Spec.Message with type t = GetMessagesResponse.t )

      module StreamMessages = struct
        let package_name = Some "masc.v1"
        let service_name = "MASCService"
        let method_name = "StreamMessages"
        let name = "/masc.v1.MASCService/StreamMessages"
        module Request = StreamMessagesRequest
        module Response = Message
      end

      let streamMessages =
        (module StreamMessagesRequest : Runtime'.Spec.Message with type t = StreamMessagesRequest.t ),
        (module Message : Runtime'.Spec.Message with type t = Message.t )

      module CreateVote = struct
        let package_name = Some "masc.v1"
        let service_name = "MASCService"
        let method_name = "CreateVote"
        let name = "/masc.v1.MASCService/CreateVote"
        module Request = CreateVoteRequest
        module Response = CreateVoteResponse
      end

      let createVote =
        (module CreateVoteRequest : Runtime'.Spec.Message with type t = CreateVoteRequest.t ),
        (module CreateVoteResponse : Runtime'.Spec.Message with type t = CreateVoteResponse.t )

      module CastVote = struct
        let package_name = Some "masc.v1"
        let service_name = "MASCService"
        let method_name = "CastVote"
        let name = "/masc.v1.MASCService/CastVote"
        module Request = CastVoteRequest
        module Response = CastVoteResponse
      end

      let castVote =
        (module CastVoteRequest : Runtime'.Spec.Message with type t = CastVoteRequest.t ),
        (module CastVoteResponse : Runtime'.Spec.Message with type t = CastVoteResponse.t )

      module InitPlan = struct
        let package_name = Some "masc.v1"
        let service_name = "MASCService"
        let method_name = "InitPlan"
        let name = "/masc.v1.MASCService/InitPlan"
        module Request = InitPlanRequest
        module Response = InitPlanResponse
      end

      let initPlan =
        (module InitPlanRequest : Runtime'.Spec.Message with type t = InitPlanRequest.t ),
        (module InitPlanResponse : Runtime'.Spec.Message with type t = InitPlanResponse.t )

      module UpdatePlan = struct
        let package_name = Some "masc.v1"
        let service_name = "MASCService"
        let method_name = "UpdatePlan"
        let name = "/masc.v1.MASCService/UpdatePlan"
        module Request = UpdatePlanRequest
        module Response = UpdatePlanResponse
      end

      let updatePlan =
        (module UpdatePlanRequest : Runtime'.Spec.Message with type t = UpdatePlanRequest.t ),
        (module UpdatePlanResponse : Runtime'.Spec.Message with type t = UpdatePlanResponse.t )

      module AddNote = struct
        let package_name = Some "masc.v1"
        let service_name = "MASCService"
        let method_name = "AddNote"
        let name = "/masc.v1.MASCService/AddNote"
        module Request = AddNoteRequest
        module Response = AddNoteResponse
      end

      let addNote =
        (module AddNoteRequest : Runtime'.Spec.Message with type t = AddNoteRequest.t ),
        (module AddNoteResponse : Runtime'.Spec.Message with type t = AddNoteResponse.t )

      module GetPlan = struct
        let package_name = Some "masc.v1"
        let service_name = "MASCService"
        let method_name = "GetPlan"
        let name = "/masc.v1.MASCService/GetPlan"
        module Request = GetPlanRequest
        module Response = GetPlanResponse
      end

      let getPlan =
        (module GetPlanRequest : Runtime'.Spec.Message with type t = GetPlanRequest.t ),
        (module GetPlanResponse : Runtime'.Spec.Message with type t = GetPlanResponse.t )

    end

  end
end

